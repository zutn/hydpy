autodoctools

This module implements tools for increasing the level of automation
and standardisation of the online documentation generated with Sphinx.

Module

autodoctools

 implements the following members:

   description() Returns the first "paragraph" of the docstring of the
   given object.

   make_autodoc_optional() Decorate function related to automatic
   documentation refinement, so that they will be applied only when
   requested (when use_autodoc of module config is True) or when
   possible (when HydPy is not frozen/bundled).

   autodoc_basemodel() Add an exhaustive docstring to the __init__
   module of a basemodel.

   autodoc_applicationmodel() Improves the docstrings of application
   models when called at the bottom of the respective module.

   Substituter Implements a HydPy specific docstring substitution
   mechanism.

   prepare_mainsubstituter() Prepare and return a Substituter object
   for the main __init__ file of HydPy.

   autodoc_module() Add a short summary of all implemented members to
   a modules docstring.


hydpy.core.autodoctools.description(self)

   Returns the first "paragraph" of the docstring of the given object.

   Note that ugly things like multiple whitespaces and newline
   characters are removed:

   >>> from hydpy.core import autodoctools, objecttools
   >>> autodoctools.description(objecttools.augment_excmessage)
   'Augment an exception message with additional information while keeping the original traceback.'

   In case the given object does not define a docstring, the following
   is returned: >>> autodoctools.description(type('Test', (), {})) 'no
   description available'

hydpy.core.autodoctools.make_autodoc_optional(wrapped, instance, args, kwargs)

   Decorate function related to automatic documentation refinement, so
   that they will be applied only when requested (when *use_autodoc*
   of module "config" is *True*) or when possible (when *HydPy* is not
   frozen/bundled).

hydpy.core.autodoctools.autodoc_basemodel()

   Add an exhaustive docstring to the *__init__* module of a
   basemodel.

   One just has to write *autodoc_basemodel()* at the bottom of an
   *__init__* module of a basemodel, and all model, parameter and
   sequence information are appended to the modules docstring.  The
   resulting docstring is suitable automatic documentation generation
   via *Sphinx* and *autodoc*.  Hence it helps in constructing HydPy's
   online documentation and supports the embeded help feature of
   *Spyder* (to see the result, import the package of an arbitrary
   basemodel, e.g. *from hydpy.models import lland* and press *cntr+i*
   with the cursor placed on *lland* written in the IPython console
   afterwards).

   Note that the resulting documentation will be complete only when
   the modules of the basemodel are named in the standard way, e.g.
   *lland_model*, *lland_control*, *lland_inputs*.

hydpy.core.autodoctools.autodoc_applicationmodel()

   Improves the docstrings of application models when called at the
   bottom of the respective module.

   autodoc_applicationmodel()

    requires, similar to

   autodoc_basemodel()

   , that both the application model and its base model are defined in
   the conventional way.

class hydpy.core.autodoctools.Substituter(master=None)

   Bases:

   object

   Implements a HydPy specific docstring substitution mechanism.

   static consider_member(name_member, member, module)

      Return "True" if the given member should be add to the
      substitutions. If not return "False".

      Some examples based on the site-package

      numpy

      :

      >>> from hydpy.core.autodoctools import Substituter
      >>> import numpy

      A constant like "nan" should be added:

      >>> Substituter.consider_member(
      ...     'nan', numpy.nan, numpy)
      True

      Members with a prefixed underscore should not be added:

      >>> Substituter.consider_member(
      ...     '_NoValue', numpy._NoValue, numpy)
      False

      Members that are actually imported modules should not be added:

      >>> Substituter.consider_member(
      ...     'warnings', numpy.warnings, numpy)
      False

      Members that are actually defined in other modules should not be
      added:

      >>> numpy.Substituter = Substituter
      >>> Substituter.consider_member(
      ...     'Substituter', numpy.Substituter, numpy)
      False
      >>> del numpy.Substituter

      Members that are defined in submodules of a given package
      (either from the standard library or from site-packages) should
      be added...

      >>> Substituter.consider_member(
      ...     'clip', numpy.clip, numpy)
      True

      ...but not members defined in

      HydPy

       submodules:

      >>> import hydpy
      >>> Substituter.consider_member(
      ...     'Node', hydpy.Node, hydpy)
      False

   static get_role(member, cython=False)

      Return the reStructuredText role *func*, *class*, or *const*
      best describing the given member.

      Some examples based on the site-package

      numpy

      .

      clip()

       is a function:

      >>> from hydpy.core.autodoctools import Substituter
      >>> import numpy
      >>> Substituter.get_role(numpy.clip)
      'func'

      ndarray

       is a class:

      >>> Substituter.get_role(numpy.ndarray)
      'class'

      "clip()" is a method, for which also the *function* role is
      returned:

      >>> Substituter.get_role(numpy.ndarray.clip)
      'func'

      For everything else the *constant* role is returned:

      >>> Substituter.get_role(numpy.nan)
      'const'

      When analysing cython extension modules, set the option *cython*
      flag to "True".  "Double" is correctly identified as a class:

      >>> from hydpy.cythons import pointerutils
      >>> Substituter.get_role(pointerutils.Double, cython=True)
      'class'

      Only with the *cython* flag beeing "True", for everything else
      the *function* text role is returned (doesn't make sense here,
      but the

      numpy

       module is not something defined in module "pointerutils"
      anyway):

      >>> Substituter.get_role(pointerutils.numpy, cython=True)
      'func'

   add_substitution(short, medium, long, module)

      Add the given substitutions both as a *short2long* and a
      *medium2long* mapping.

      Assume *variable1* is defined in the hydpy module *module1* and
      the short and medium descriptions are *var1* and *mod1.var1*:

      >>> import types
      >>> module1 = types.ModuleType('hydpy.module1')
      >>> from hydpy.core.autodoctools import Substituter
      >>> substituter = Substituter()
      >>> substituter.add_substitution(
      ...     'var1', 'mod1.var1', 'module1.variable1', module1)
      >>> print(substituter.get_commands())
      .. var1 replace:: module1.variable1
      .. mod1.var1 replace:: module1.variable1

      Adding *variable2* of *module2* has no effect on the predefined
      substitutions:

      >>> module2 = types.ModuleType('hydpy.module2')
      >>> substituter.add_substitution(
      ...     'var2', 'mod2.var2', 'module2.variable2', module2)
      >>> print(substituter.get_commands())
      .. var1 replace:: module1.variable1
      .. var2 replace:: module2.variable2
      .. mod1.var1 replace:: module1.variable1
      .. mod2.var2 replace:: module2.variable2

      But when adding *variable1* of *module2*, the *short2long*
      mapping of *variable1* would become inconclusive, which is why
      the new one (related to *module2*) is not stored and the old one
      (related to *module1*) is removed:

      >>> substituter.add_substitution(
      ...     'var1', 'mod2.var1', 'module2.variable1', module2)
      >>> print(substituter.get_commands())
      .. var2 replace:: module2.variable2
      .. mod1.var1 replace:: module1.variable1
      .. mod2.var1 replace:: module2.variable1
      .. mod2.var2 replace:: module2.variable2

      Adding *variable2* of *module2* accidentally again, does not
      result in any undesired side-effects:

      >>> substituter.add_substitution(
      ...     'var2', 'mod2.var2', 'module2.variable2', module2)
      >>> print(substituter.get_commands())
      .. var2 replace:: module2.variable2
      .. mod1.var1 replace:: module1.variable1
      .. mod2.var1 replace:: module2.variable1
      .. mod2.var2 replace:: module2.variable2

      In order to reduce the risk of name conflicts, only the
      *medium2long* mapping is supported for modules not part of the

      HydPy

       package:

      >>> module3 = types.ModuleType('module3')
      >>> substituter.add_substitution(
      ...     'var3', 'mod3.var3', 'module3.variable3', module3)
      >>> print(substituter.get_commands())
      .. var2 replace:: module2.variable2
      .. mod1.var1 replace:: module1.variable1
      .. mod2.var1 replace:: module2.variable1
      .. mod2.var2 replace:: module2.variable2
      .. mod3.var3 replace:: module3.variable3

      The only exception to this rule is

      builtins

      , for which only the *short2long* mapping is supported (note
      also, that the module name *builtins* is removed from string
      *long*):

      >>> from hydpy import builtins
      >>> substituter.add_substitution(
      ...     'str', 'blt.str', ':func:`~builtins.str`', builtins)
      >>> print(substituter.get_commands())
      .. str replace:: :func:`str`
      .. var2 replace:: module2.variable2
      .. mod1.var1 replace:: module1.variable1
      .. mod2.var1 replace:: module2.variable1
      .. mod2.var2 replace:: module2.variable2
      .. mod3.var3 replace:: module3.variable3

   add_module(module, cython=False)

      Add the given module, its members, and their submembers.

      The first examples are based on the site-package

      numpy

      : which is passed to method

      add_module()

      :

      >>> from hydpy.core.autodoctools import Substituter
      >>> substituter = Substituter()
      >>> import numpy
      >>> substituter.add_module(numpy)

      Firstly, the module itself is added:

      >>> substituter.find('|numpy|')
      |numpy| :mod:`~numpy`

      Secondly, constants like "nan" are added:

      >>> substituter.find('|numpy.nan|')
      |numpy.nan| :const:`~numpy.nan`

      Thirdly, functions like

      clip()

       are added:

      >>> substituter.find('|numpy.clip|')
      |numpy.clip| :func:`~numpy.clip`

      Fourthly, clases line

      ndarray

       are added:

      >>> substituter.find('|numpy.ndarray|')
      |numpy.ndarray| :class:`~numpy.ndarray`

      When adding Cython modules, the *cython* flag should be set
      "True":

      >>> from hydpy.cythons import pointerutils
      >>> substituter.add_module(pointerutils, cython=True)
      >>> substituter.find('set_pointer')
      |PPDouble.set_pointer| :func:`~hydpy.cythons.autogen.pointerutils.PPDouble.set_pointer`
      |pointerutils.PPDouble.set_pointer| :func:`~hydpy.cythons.autogen.pointerutils.PPDouble.set_pointer`

   add_modules(package)

      Add the modules of the given package without their members.

   update_masters()

      Update all *master*

      Substituter

       objects.

      If a

      Substituter

       objects is passed to the constructor of another

      Substituter

       object, it becomes its *master*:

      >>> from hydpy.core.autodoctools import Substituter
      >>> sub1 = Substituter()
      >>> from hydpy.core import devicetools
      >>> sub1.add_module(devicetools)
      >>> sub2 = Substituter(sub1)
      >>> sub3 = Substituter(sub2)
      >>> sub3.master.master is sub1
      True

      During initialization, all mappings handled by the master object
      are passed to its slave:

      >>> sub3.find('Node|')
      |Node| :class:`~hydpy.core.devicetools.Node`
      |devicetools.Node| :class:`~hydpy.core.devicetools.Node`

      Updating a slave, does not affect its master directly:

      >>> from hydpy.core import hydpytools
      >>> sub3.add_module(hydpytools)
      >>> sub3.find('HydPy|')
      |HydPy| :class:`~hydpy.core.hydpytools.HydPy`
      |hydpytools.HydPy| :class:`~hydpy.core.hydpytools.HydPy`
      >>> sub2.find('HydPy|')

      Through calling

      update_masters()

      , the *medium2long* mappings are passed the slave to its master:

      >>> sub3.update_masters()
      >>> sub2.find('HydPy|')
      |hydpytools.HydPy| :class:`~hydpy.core.hydpytools.HydPy`

      Then each master object updates its own master object also:

      >>> sub1.find('HydPy|')
      |hydpytools.HydPy| :class:`~hydpy.core.hydpytools.HydPy`

   get_commands(source=None)

      Return a string containing multiple *reStructuredText*
      replacements with the substitutions currently defined.

      Some examples based on the subpackage

      optiontools

      :

      >>> from hydpy.core.autodoctools import Substituter
      >>> substituter = Substituter()
      >>> from hydpy.core import optiontools
      >>> substituter.add_module(optiontools)

      When calling

      get_commands()

       with the *source* argument, the complete *short2long* and
      *medium2long* mappings are translated into replacement commands
      (only a few of them are shown):

      >>> print(substituter.get_commands())
      .. |Options.checkseries| replace:: :const:`~hydpy.core.optiontools.Options.checkseries`
      .. |Options.dirverbose| replace:: :const:`~hydpy.core.optiontools.Options.dirverbose`
      ...
      .. |optiontools.Options.warntrim| replace:: :const:`~hydpy.core.optiontools.Options.warntrim`
      .. |optiontools.Options| replace:: :class:`~hydpy.core.optiontools.Options`

      Through passing a string (usually the source code of a file to
      be documented), only the replacement commands relevant for this
      string are translated:

      >>> from hydpy.core import objecttools
      >>> import inspect
      >>> source = inspect.getsource(objecttools)
      >>> print(substituter.get_commands(source))
      .. |Options.reprdigits| replace:: :const:`~hydpy.core.optiontools.Options.reprdigits`

   find(text)

      Print all substitutions that include the given text string.

hydpy.core.autodoctools.prepare_mainsubstituter()

   Prepare and return a

   Substituter

    object for the main *__init__* file of

   HydPy

   .

hydpy.core.autodoctools.autodoc_module()

   Add a short summary of all implemented members to a modules
   docstring.

   Just write *autodoctools.autodoc_module()* at the very bottom of
   the module.

   Note that function

   autodoc_module()

    is not thought to be used for modules defining models.  For base
   models, see function

   autodoc_basemodel()

    instead.
