objecttools

This module implements tools to help to standardize the functionality
of the different objects defined by the HydPy framework.

Module

objecttools

 implements the following members:

   assignrepr_list "Double Singleton class", see the documentation on
   assignrepr_tuple and assignrepr_list.

   assignrepr_tuple "Double Singleton class", see the documentation on
   assignrepr_tuple and assignrepr_list.

   repr_ Modifies repr() for strings and floats, mainly for supporting
   clean float representations that are compatible with doctest.

   dir_() The prefered way for HydPy objects to respond to dir().

   classname() Return the class name of the given instance object or
   class.

   instancename() Return the class name of the given instance object
   or class in lower case letters.

   value_of_type() Returns a string containing both the informal
   string and the type of the given value.

   name() Name of the class of the given instance in lower case
   letters.

   modulename() Return the module name of the given instance object.

   devicename() Try to return the name of the (indirect) master Node
   or Element instance, if not possible return ?.

   elementphrase() Return the phrase used in exception messages to
   indicate which Element is affected.

   nodephrase() Return the phrase used in exception messages to
   indicate which Node is affected.

   devicephrase() Try to return the phrase used in exception messages
   to indicate which Element or which Node is affected. If not
   possible return a single empty space.

   valid_variable_identifier() Raises an ValueError if the given name
   is not a valid Python identifier.

   augment_excmessage() Augment an exception message with additional
   information while keeping the original traceback.

   excmessage_decorator() Wrap a function with augment_excmessage().

   ResetAttrFuncs Reset all attribute related methods of the given
   class temporarily.

   copy_() Copy function for classes with modified attribute
   functions.

   deepcopy_() Deepcopy function for classes with modified attribute
   functions.

   repr_values() Return comma separated representations of the given
   values using function repr().

   print_values() Print the given values in multiple lines with a
   certain maximum width.

   repr_tuple() Return a tuple representation of the given values
   using function repr().

   repr_list() Return a list representation of the given values using
   function repr().

   assignrepr_value() Return a prefixed string representation of the
   given value using function repr().

   assignrepr_values() Return a prefixed, wrapped and properly aligned
   string representation of the given values using function repr().

   assignrepr_values2() Return a prefixed and properly aligned string
   representation of the given 2-dimensional value matrix using
   function repr().

   assignrepr_tuple2() Return a prefixed, wrapped and properly aligned
   tuple string representation of the given 2-dimensional value matrix
   using function repr().

   assignrepr_list2() Return a prefixed, wrapped and properly aligned
   list string representation of the given 2-dimensional value matrix
   using function repr().

   assignrepr_tuple3() Return a prefixed, wrapped and properly aligned
   tuple string representation of the given 3-dimensional value matrix
   using function repr().

   assignrepr_list3() Return a prefixed, wrapped and properly aligned
   list string representation of the given 3-dimensional value matrix
   using function repr().

   round_() Prints values with a maximum number of digits in doctests.

   extract() Return a generator that extracts certain objects from
   values.

   enumeration() Return an enumeration string based on the given
   values.

   FastAccess Used as a surrogate for typed Cython classes when
   working in pure Python mode.

   HydPyDeprecationWarning no description available


hydpy.core.objecttools.dir_(self)

   The prefered way for HydPy objects to respond to

   dir()

   .

   Note the depencence on the *pub.options.dirverbose*.  If this
   option is set *True*, all attributes and methods of the given
   instance and its class (including those inherited from the parent
   classes) are returned:

   >>> from hydpy.pub import options
   >>> options.dirverbose = True
   >>> from hydpy.core.objecttools import dir_
   >>> class Test(object):
   ...     only_public_attribute =  None
   >>> print(len(dir_(Test())) > 1) # Long list, try it yourself...
   True

   If the option is set to *False*, only the *public* attributes and
   methods (which do need begin with *_*) are returned:

   >>> options.dirverbose = False
   >>> print(dir_(Test())) # Short list with one single entry...
   ['only_public_attribute']

hydpy.core.objecttools.classname(self)

   Return the class name of the given instance object or class.

   >>> from hydpy.core.objecttools import classname
   >>> from hydpy.pub import options
   >>> print(classname(float))
   float
   >>> print(classname(options))
   Options

hydpy.core.objecttools.instancename(self)

   Return the class name of the given instance object or class in
   lower case letters.

   >>> from hydpy.core.objecttools import instancename
   >>> from hydpy.pub import options
   >>> print(instancename(options))
   options

hydpy.core.objecttools.value_of_type(value)

   Returns a string containing both the informal string and the type
   of the given value.

   This function is intended to simplifying writing HydPy exceptions,
   which frequently contain the following phrase:

   >>> from hydpy.core.objecttools import value_of_type
   >>> value_of_type(999)
   'value `999` of type `int`'

hydpy.core.objecttools.name(self)

   Name of the class of the given instance in lower case letters.

   This function is thought to be implemented as a property.
   Otherwise it would violate the principle not to access or
   manipulate private attributes ("_name"):

   >>> from hydpy.core.objecttools import name
   >>> class Test(object):
   ...     name = property(name)
   >>> test1 = Test()
   >>> test1.name
   'test'
   >>> test1._name
   'test'

   The private attribute is added for performance reasons only.  Note
   that it is a class attribute:

   >>> test2 = Test()
   >>> test2._name
   'test'

hydpy.core.objecttools.modulename(self)

   Return the module name of the given instance object.

   >>> from hydpy.core.objecttools import modulename
   >>> from hydpy.pub import options
   >>> print(modulename(options))
   optiontools

hydpy.core.objecttools.devicename(self)

   Try to return the name of the (indirect) master

   Node

    or

   Element

    instance, if not possible return *?*.

   >>> from hydpy.core.modeltools import Model
   >>> model = Model()
   >>> from hydpy.core.objecttools import devicename
   >>> devicename(model)
   '?'

   >>> from hydpy import Element
   >>> e1 = Element('e1')
   >>> e1.connect(model)
   >>> devicename(model)
   'e1'

hydpy.core.objecttools.elementphrase(self)

   Return the phrase used in exception messages to indicate which

   Element

    is affected.

   >>> from hydpy.core.modeltools import Model
   >>> model = Model()
   >>> from hydpy.core.objecttools import elementphrase
   >>> elementphrase(model)
   ' of element `?` '

   >>> from hydpy import Element
   >>> e1 = Element('e1')
   >>> e1.connect(model)
   >>> elementphrase(model)
   ' of element `e1` '

hydpy.core.objecttools.nodephrase(self)

   Return the phrase used in exception messages to indicate which

   Node

    is affected.

   >>> from hydpy.core.sequencetools import Sequences
   >>> sequences = Sequences()
   >>> from hydpy.core.objecttools import nodephrase
   >>> nodephrase(sequences)
   ' of node `?` '

   >>> from hydpy import Node
   >>> n1 = Node('n1')
   >>> nodephrase(n1.sequences.sim)
   ' of node `n1` '

hydpy.core.objecttools.devicephrase(self)

   Try to return the phrase used in exception messages to indicate
   which

   Element

    or which

   Node

    is affected. If not possible return a single empty space.

   >>> from hydpy.core.modeltools import Model
   >>> model = Model()
   >>> from hydpy.core.objecttools import devicephrase
   >>> devicephrase(model)
   ' '

   >>> from hydpy import Element
   >>> e1 = Element('e1')
   >>> e1.connect(model)
   >>> devicephrase(model)
   ' of element `e1` '

   >>> from hydpy import Node
   >>> n1 = Node('n1')
   >>> devicephrase(n1.sequences.sim)
   ' of node `n1` '

hydpy.core.objecttools.valid_variable_identifier(name)

   Raises an

   ValueError

    if the given name is not a valid Python identifier.

   For example, the string *test_1* (with underscore) is valid...

   >>> from hydpy.core.objecttools import valid_variable_identifier
   >>> valid_variable_identifier('test_1')

   ...but the string *test 1* (with white space) is not:

   >>> valid_variable_identifier('test 1')
   Traceback (most recent call last):
   ...
   ValueError: The given name string `test 1` does not define a valid variable identifier.  Valid identifiers do not contain characters like `-` or empty spaces, do not start with numbers, cannot be mistaken with Python built-ins like `for`...)

   Also, names of Python built ins are not allowed:

   >>> valid_variable_identifier('while')
   Traceback (most recent call last):
   ...
   ValueError: The given name string `while` does not define...

hydpy.core.objecttools.augment_excmessage(prefix=None, suffix=None)

   Augment an exception message with additional information while
   keeping the original traceback.

   You can prefix and/or suffix text.  If you prefix something (which
   happens much more often in the HydPy framework), the sub-clause ',
   the following error occured:' is automatically included:

   >>> from hydpy.core import objecttools
   >>> import textwrap
   >>> try:
   ...     1 + '1'
   ... except TypeError:
   ...     try:
   ...         prefix = 'While showing how prefixing works'
   ...         suffix = '(This is a final remark.)'
   ...         objecttools.augment_excmessage(prefix, suffix)
   ...     except TypeError as exc:
   ...         for line in textwrap.wrap(exc.args[0], width=76):
   ...             print(line)
   While showing how prefixing works, the following error occured: unsupported
   operand type(s) for +: 'int' and 'str' (This is a final remark.)

   Note that the ancillary purpose of function

   augment_excmessage()

    is to make re-raising exceptions compatible with both Python 2 and
   3.

hydpy.core.objecttools.excmessage_decorator(description)

   Wrap a function with

   augment_excmessage()

   .

   Function

   excmessage_decorator()

    is a means to apply function

   augment_excmessage()

    more efficiently.  Suppose you would apply function

   augment_excmessage()

    in a function that adds and returns to numbers:

   >>> from  hydpy.core import objecttools
   >>> def add(x, y):
   ...     try:
   ...         return x + y
   ...     except BaseException:
   ...         objecttools.augment_excmessage(
   ...             'While trying to add `x` and `y`')

   This works as excepted...

   >>> add(1, 2)
   3
   >>> add(1, [])
   Traceback (most recent call last):
   ...
   TypeError: While trying to add `x` and `y`, the following error occured: unsupported operand type(s) for +: 'int' and 'list'

   ...but can be achieved with much less code using

   excmessage_decorator()

   :

   >>> @objecttools.excmessage_decorator(
   ...     'add `x` and `y`')
   ... def add(x, y):
   ...     return x+y

   >>> add(1, 2)
   3

   >>> add(1, [])
   Traceback (most recent call last):
   ...
   TypeError: While trying to add `x` and `y`, the following error occured: unsupported operand type(s) for +: 'int' and 'list'

   Additionally, exception messages related to wrong function calls
   are now also augmented (the end of the message depends on the
   employed Python version):

   >>> add(1)
   Traceback (most recent call last):
   ...
   TypeError: While trying to add `x` and `y`, the following error occured: add() ...

   It is made sure that no information of the decorated function is
   lost:

   >>> add.__name__
   'add'

class hydpy.core.objecttools.ResetAttrFuncs(obj)

   Bases:

   object

   Reset all attribute related methods of the given class temporarily.

   The "related methods" are defined in class attribute

   funcnames

   .

   There are (at least) two use cases for  class

   ResetAttrFuncs

   , initialization and copying, which are described below.

   In HydPy, some classes define a *__setattr__* method which raises
   exceptions when one tries to set "improper" instance attributes.
   The problem is, that such customized *setattr* methods often
   prevent from defining instance attributes within *__init__* methods
   in the usual manner.  Working on instance dictionaries instead can
   confuse some automatic tools (e.g. pylint).  Class

   ResetAttrFuncs

    implements a trick to circumvent this problem.

   To show how

   ResetAttrFuncs

    works, we first define a class with a *__setattr__* method that
   does not allow to set any attribute:

   >>> class Test(object):
   ...     def __setattr__(self, name, value):
   ...         raise AttributeError
   >>> test = Test()
   >>> test.var1 = 1
   Traceback (most recent call last):
   ...
   AttributeError

   Assigning this class to

   ResetAttrFuncs

    allows for setting attributes to all its instances inside a *with*
   block in the usual manner:

   >>> from hydpy.core.objecttools import ResetAttrFuncs
   >>> with ResetAttrFuncs(test):
   ...     test.var1 = 1
   >>> test.var1
   1

   After the end of the *with* block, the custom *__setattr__* method
   of the test class works again and prevents from setting attributes:

   >>> test.var2 = 2
   Traceback (most recent call last):
   ...
   AttributeError

   The second use case is related to method *__getattr__* and copying.
   The following test class stores its attributes (for whatever
   reasons) in a special dictionary called "dic" (note that how

   ResetAttrFuncs

    is used in the *__init__* method):

   >>> class Test(object):
   ...     def __init__(self):
   ...         with ResetAttrFuncs(self):
   ...             self.dic = {}
   ...     def __setattr__(self, name, value):
   ...         self.dic[name] = value
   ...     def __getattr__(self, name):
   ...         try:
   ...             return self.dic[name]
   ...         except KeyError:
   ...             raise AttributeError

   Principally, this simple implementation does its job but its
   instances are not easily copyable under all Python versions:

   >>> test = Test()
   >>> test.var1 = 1
   >>> test.var1
   1
   >>> import copy
   >>> copy.deepcopy(test)   # doctest: +SKIP
   Traceback (most recent call last):
   ...
   RecursionError: maximum recursion depth exceeded ...

   ResetAttrFuncs

    can be used to implement specialized *__copy__* and *__deepcopy__*
   methods, which rely on the temporary disabling of *__getattr__*.
   For simple cases, one can import the predefined functions

   copy_()

    and

   deepcopy_()

   :

   >>> from hydpy.core.objecttools import copy_, deepcopy_
   >>> Test.__copy__ = copy_
   >>> test2 = copy.copy(test)
   >>> test2.var1
   1
   >>> Test.__deepcopy__ = deepcopy_
   >>> test3 = copy.deepcopy(test)
   >>> test3.var1
   1

   Note that an infinite recursion is avoided by also disabling
   methods *__copy__* and *__deepcopy__* themselves.

   funcnames = ('__getattr__', '__setattr__', '__delattr__', '__copy__', '__deepcopy__')

   cls

   name2func

hydpy.core.objecttools.copy_(self)

   Copy function for classes with modified attribute functions.

   See the documentation on class

   ResetAttrFuncs

    for further information.

hydpy.core.objecttools.deepcopy_(self, memo)

   Deepcopy function for classes with modified attribute functions.

   See the documentation on class

   ResetAttrFuncs

    for further information.

hydpy.core.objecttools.repr_values(values)

   Return comma separated representations of the given values using
   function

   repr()

   .

   >>> from hydpy.core.objecttools import repr_values
   >>> repr_values([1./1., 1./2., 1./3.])
   '1.0, 0.5, 0.333333'

   Note that the returned string is not wrapped.

hydpy.core.objecttools.print_values(values, width=70)

   Print the given values in multiple lines with a certain maximum
   width.

   By default, each line contains at most 70 characters:

   >>> from hydpy import print_values
   >>> print_values(range(21))
   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
   20

   You can change this default behaviour by passing an alternative
   number of characters:

   >>> print_values(range(21), width=30)
   0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
   10, 11, 12, 13, 14, 15, 16,
   17, 18, 19, 20

hydpy.core.objecttools.repr_tuple(values)

   Return a tuple representation of the given values using function

   repr()

   .

   >>> from hydpy.core.objecttools import repr_tuple
   >>> repr_tuple([1./1., 1./2., 1./3.])
   '(1.0, 0.5, 0.333333)'

   Note that the returned string is not wrapped.

   In the special case of an iterable with only one entry, the
   returned string is still a valid tuple:

   >>> repr_tuple([1.])
   '(1.0,)'

hydpy.core.objecttools.repr_list(values)

   Return a list representation of the given values using function

   repr()

   .

   >>> from hydpy.core.objecttools import repr_list
   >>> repr_list([1./1., 1./2., 1./3.])
   '[1.0, 0.5, 0.333333]'

   Note that the returned string is not wrapped.

hydpy.core.objecttools.assignrepr_value(value, prefix, width=None)

   Return a prefixed string representation of the given value using
   function

   repr()

   .

   Note that the argument has no effect. It is thought for increasing
   usage compatibility with functions like

   assignrepr_list

    only.

   >>> from hydpy.core.objecttools import assignrepr_value
   >>> print(assignrepr_value(1./3., 'test = '))
   test = 0.333333

hydpy.core.objecttools.assignrepr_values(values, prefix, width=None, _fakeend=0)

   Return a prefixed, wrapped and properly aligned string
   representation of the given values using function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_values
   >>> print(assignrepr_values(range(1, 13), 'test(', 20) + ')')
   test(1, 2, 3, 4, 5,
        6, 7, 8, 9, 10,
        11, 12)

   If no width is given, no wrapping is performed:

   >>> print(assignrepr_values(range(1, 13), 'test(') + ')')
   test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)

   To circumvent defining too long string representations, make use of
   the ellipsis option:

   >>> from hydpy.pub import options
   >>> with options.ellipsis(1):
   ...     print(assignrepr_values(range(1, 13), 'test(', 20) + ')')
   test(1, ...,12)

   >>> with options.ellipsis(5):
   ...     print(assignrepr_values(range(1, 13), 'test(', 20) + ')')
   test(1, 2, 3, 4, 5,
        ...,8, 9, 10,
        11, 12)

   >>> with options.ellipsis(6):
   ...     print(assignrepr_values(range(1, 13), 'test(', 20) + ')')
   test(1, 2, 3, 4, 5,
        6, 7, 8, 9, 10,
        11, 12)

hydpy.core.objecttools.assignrepr_tuple = <hydpy.core.objecttools._AssignReprBracketed object>

   Return a prefixed, wrapped and properly aligned tuple string
   representation of the given values using function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_tuple
   >>> print(assignrepr_tuple(range(10), 'test = ', 22))
   test = (0, 1, 2, 3, 4,
           5, 6, 7, 8, 9)

   If no width is given, no wrapping is performed:

   >>> print(assignrepr_tuple(range(10), 'test = '))
   test = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

   Functions

   assignrepr_tuple

    works also on empty iterables and those which possess only one
   entry:

   >>> print(assignrepr_tuple([], 'test = '))
   test = ()
   >>> print(assignrepr_tuple([10], 'test = '))
   test = (10,)

   Optionally, bracketing single values can be prevented:

   >>> with assignrepr_tuple.always_bracketed(False):
   ...     print(assignrepr_tuple([], 'test = '))
   ...     print(assignrepr_tuple([10], 'test = '))
   ...     print(assignrepr_tuple([10, 10], 'test = '))
   test = ()
   test = 10
   test = (10, 10)

   Behind the with block,

   assignrepr_tuple

    works as before (even in case of an error):

   >>> print(assignrepr_tuple([10], 'test = '))
   test = (10,)

hydpy.core.objecttools.assignrepr_list = <hydpy.core.objecttools._AssignReprBracketed object>

   Return a prefixed, wrapped and properly aligned list string
   representation of the given values using function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_list
   >>> print(assignrepr_list(range(10), 'test = ', 22))
   test = [0, 1, 2, 3, 4,
           5, 6, 7, 8, 9]

   If no width is given, no wrapping is performed:

   >>> print(assignrepr_list(range(10), 'test = '))
   test = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

   Functions

   assignrepr_list

    works also on empty iterables:

   >>> print(assignrepr_list((), 'test = '))
   test = []

   Optionally, bracketing single values can be prevented:

   >>> with assignrepr_list.always_bracketed(False):
   ...     print(assignrepr_list([], 'test = '))
   ...     print(assignrepr_list([10], 'test = '))
   ...     print(assignrepr_list([10, 10], 'test = '))
   test = []
   test = 10
   test = [10, 10]

   Behind the with block,

   assignrepr_list

    works as before (even in case of an error):

   >>> print(assignrepr_list([10], 'test = '))
   test = [10,]

hydpy.core.objecttools.assignrepr_values2(values, prefix)

   Return a prefixed and properly aligned string representation of the
   given 2-dimensional value matrix using function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_values2
   >>> import numpy
   >>> print(assignrepr_values2(numpy.eye(3), 'test(') + ')')
   test(1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0)

   Functions

   assignrepr_values2()

    works also on empty iterables:

   >>> print(assignrepr_values2([[]], 'test(') + ')')
   test()

hydpy.core.objecttools.assignrepr_tuple2(values, prefix, width=None)

   Return a prefixed, wrapped and properly aligned tuple string
   representation of the given 2-dimensional value matrix using
   function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_tuple2
   >>> import numpy
   >>> print(assignrepr_tuple2(numpy.eye(3), 'test = ', 18))
   test = ((1.0, 0.0,
            0.0),
           (0.0, 1.0,
            0.0),
           (0.0, 0.0,
            1.0))

   If no width is given, no wrapping is performed:

   >>> print(assignrepr_tuple2(numpy.eye(3), 'test = '))
   test = ((1.0, 0.0, 0.0),
           (0.0, 1.0, 0.0),
           (0.0, 0.0, 1.0))

   Functions

   assignrepr_tuple2()

    works also on empty iterables and those which possess only one
   entry:

   >>> print(assignrepr_tuple2([[]], 'test = '))
   test = (())
   >>> print(assignrepr_tuple2([[], [1]], 'test = '))
   test = ((),
           (1,))

hydpy.core.objecttools.assignrepr_list2(values, prefix, width=None)

   Return a prefixed, wrapped and properly aligned list string
   representation of the given 2-dimensional value matrix using
   function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_list2
   >>> import numpy
   >>> print(assignrepr_list2(numpy.eye(3), 'test = ', 18))
   test = [[1.0, 0.0,
            0.0],
           [0.0, 1.0,
            0.0],
           [0.0, 0.0,
            1.0]]

   If no width is given, no wrapping is performed:

   >>> print(assignrepr_list2(numpy.eye(3), 'test = '))
   test = [[1.0, 0.0, 0.0],
           [0.0, 1.0, 0.0],
           [0.0, 0.0, 1.0]]

   Functions

   assignrepr_list2()

    works also on empty iterables:

   >>> print(assignrepr_list2([[]], 'test = '))
   test = [[]]
   >>> print(assignrepr_list2([[], [1]], 'test = '))
   test = [[],
           [1]]

hydpy.core.objecttools.assignrepr_tuple3(values, prefix, width=None)

   Return a prefixed, wrapped and properly aligned tuple string
   representation of the given 3-dimensional value matrix using
   function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_tuple3
   >>> import numpy
   >>> values = [numpy.eye(3), numpy.ones((3, 3))]
   >>> print(assignrepr_tuple3(values, 'test = ', 18))
   test = (((1.0,
             0.0,
             0.0),
            (0.0,
             1.0,
             0.0),
            (0.0,
             0.0,
             1.0)),
           ((1.0,
             1.0,
             1.0),
            (1.0,
             1.0,
             1.0),
            (1.0,
             1.0,
             1.0)))

   If no width is given, no wrapping is performed:

   >>> print(assignrepr_tuple3(values, 'test = '))
   test = (((1.0, 0.0, 0.0),
            (0.0, 1.0, 0.0),
            (0.0, 0.0, 1.0)),
           ((1.0, 1.0, 1.0),
            (1.0, 1.0, 1.0),
            (1.0, 1.0, 1.0)))

   Functions

   assignrepr_tuple3()

    works also on empty iterables and those which possess only one
   entry:

   >>> print(assignrepr_tuple3([[[]]], 'test = '))
   test = (((),),)
   >>> print(assignrepr_tuple3([[[], [1]]], 'test = '))
   test = (((),
            (1,)),)

hydpy.core.objecttools.assignrepr_list3(values, prefix, width=None)

   Return a prefixed, wrapped and properly aligned list string
   representation of the given 3-dimensional value matrix using
   function

   repr()

   .

   >>> from hydpy.core.objecttools import assignrepr_list3
   >>> import numpy
   >>> values = [numpy.eye(3), numpy.ones((3, 3))]
   >>> print(assignrepr_list3(values, 'test = ', 18))
   test = [[[1.0,
             0.0,
             0.0],
            [0.0,
             1.0,
             0.0],
            [0.0,
             0.0,
             1.0]],
           [[1.0,
             1.0,
             1.0],
            [1.0,
             1.0,
             1.0],
            [1.0,
             1.0,
             1.0]]]

   If no width is given, no wrapping is performed:

   >>> print(assignrepr_list3(values, 'test = '))
   test = [[[1.0, 0.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, 1.0]],
           [[1.0, 1.0, 1.0],
            [1.0, 1.0, 1.0],
            [1.0, 1.0, 1.0]]]

   Functions

   assignrepr_list3()

    works also on empty iterables and those which possess only one
   entry:

   >>> print(assignrepr_list3([[[]]], 'test = '))
   test = [[[]]]
   >>> print(assignrepr_list3([[[], [1]]], 'test = '))
   test = [[[],
            [1]]]

hydpy.core.objecttools.round_(values, decimals=None, width=0, lfill=None, rfill=None, **kwargs)

   Prints values with a maximum number of digits in doctests.

   See the documentation on function

   repr()

    for more details.  And note thate the option keyword arguments are
   passed to the print function.

   Usually one would apply function

   round_()

    on a single or a vector of numbers:

   >>> from hydpy import round_
   >>> round_(1./3., decimals=6)
   0.333333
   >>> round_((1./2., 1./3., 1./4.), decimals=4)
   0.5, 0.3333, 0.25

   Additionally, one can supply a *width* and a *rfill* argument: >>>
   round_(1.0, width=6, rfill='0') 1.0000

   Alternatively, one can use the *lfill* arguments, which might e.g.
   be usefull for aligning different strings:

   >>> round_('test', width=6, lfill='_')
   __test

   Using both the *lfill* and the *rfill* argument raises an error:

   >>> round_(1.0, lfill='_', rfill='0')
   Traceback (most recent call last):
   ...
   ValueError: For function `round_` values are passed for both arguments `lfill` and `rfill`.  This is not allowed.

hydpy.core.objecttools.extract(values, types, skip=False)

   Return a generator that extracts certain objects from *values*.

   This function is thought for supporting the definition of functions
   with arguments, that can be objects of of contain types or that can
   be iterables containing these objects.

   The following examples show that function

   extract()

    basically implements a type specific flattening mechanism:

   >>> from hydpy.core.objecttools import extract
   >>> tuple(extract('str1', (str, int)))
   ('str1',)
   >>> tuple(extract(['str1', 'str2'], (str, int)))
   ('str1', 'str2')
   >>> tuple(extract((['str1', 'str2'], [1,]), (str, int)))
   ('str1', 'str2', 1)

   If an object is neither iterable nor of the required type, the
   following exception is raised:

   >>> tuple(extract((['str1', 'str2'], [None, 1]), (str, int)))
   Traceback (most recent call last):
   ...
   TypeError: The given value `'None'` is neither iterable nor an instance of the following classes: str and int.

   Optionally, "None" values can be skipped:

   >>> tuple(extract(None, (str, int), True))
   ()
   >>> tuple(extract((['str1', 'str2'], [None, 1]), (str, int), True))
   ('str1', 'str2', 1)

hydpy.core.objecttools.enumeration(values, converter=<class 'str'>, default='')

   Return an enumeration string based on the given values.

   The following four examples show the standard output of function

   enumeration()

   :

   >>> from hydpy.core.objecttools import enumeration
   >>> enumeration(('text', 3, []))
   'text, 3, and []'
   >>> enumeration(('text', 3))
   'text and 3'
   >>> enumeration(('text',))
   'text'
   >>> enumeration(())
   ''

   All given objects are converted to strings by function

   str

   , as shown by the first two examples.  This behaviour can be
   changed by another function expecting a single argument and
   returning a string:

   >>> from hydpy.core.objecttools import classname
   >>> enumeration(('text', 3, []), converter=classname)
   'str, int, and list'

   Furthermore, you can define a default string that is returned in
   case an empty iterable is given:

   >>> enumeration((), default='nothing')
   'nothing'

class hydpy.core.objecttools.FastAccess

   Bases:

   object

   Used as a surrogate for typed Cython classes when working in pure
   Python mode.

exception hydpy.core.objecttools.HydPyDeprecationWarning

   Bases:

   DeprecationWarning
