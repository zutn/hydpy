arma_v1

Version 1 of the HydPy-A model generalises the RIMO/RIDO flood routing
approach.

RIMO/RIDO is based on the *translation diffusion equation*, which is a
linear approximation on the Saint-Venant equations involving only two
parameters - one for the celerity and one for the diffusivity of the
flood wave.  The linearity of the approach allows for constructing
Unit Hydrograph ordinates for each specific combination of celerity,
diffusivity, and the length of the considered river section.  One can
understand these ordinates as coefficients of a moving average (MA)
process.

RIMO/RIDO adds two additional features to this conventional approach.

Firstly, RIMO/RIDO approximates the response function described by the
MA coefficients by an ARMA process, which is useful for response
functions with long tails.  Very often, autoregressive (AR) models are
capable of approximating long-tailed responses sufficiently with few
parameters.  Hence, using ARMA models (which reflect the rising limb
of a response function with their MA coefficients its falling limb
with their AR coefficients) is often more parameter efficient than
using pure MA models.

Secondly, RIMO/RIDO separates the flow into the river section into
different "portions" based on discharge threshold. Each portion is
routed by a separate ARMA model, allowing to factor in the
nonlinearity of rating curves to a certain degree.  For example, the
bank-full discharge can serve as a threshold.  Then one can apply
smaller celerity values and larger diffusivity values on the "upper"
flow portion to simulate retention processes on flood-plains.

If you want to apply

arma_v1

 precisely like RIMO/RIDO, consider using

TranslationDiffusionEquation

 for calculating its coefficients. But you are free to define other
parameters, e.g. those of the

LinearStorageCascade

. Additionally, you are free to apply combined ARMA coefficients or
pure MA coefficients only, as described in the following examples.

Integration examples:

   The following tests are performed over a period of 20 hours:

   >>> from hydpy import pub, Timegrid, Timegrids, Nodes, Element
   >>> pub.timegrids = Timegrids(Timegrid('01.01.2000 00:00',
   ...                                    '01.01.2000 20:00',
   ...                                    '1h'))

   Import the model and define the time settings:

   >>> from hydpy.models.arma_v1 import *
   >>> parameterstep('1h')

   For testing purposes, the model input shall be retrieved from the
   nodes *input1* and *input2* and the model output shall be passed to
   node *output*.  Firstly, define all nodes:

   >>> nodes = Nodes('input1', 'input2', 'output')

   Define the element *stream* and build the connections between the
   nodes defined above and the

   arma_v1

    model instance:

   >>> stream = Element('stream',
   ...                  inlets=['input1', 'input2'],
   ...                  outlets='output')
   >>> stream.connect(model)

   Prepare a test function object, which prints the respective values
   of the model sequences

   QIn

   ,

   QPIn

   ,

   QPOut

   , and

   QOut

   .  The node sequence *sim* is added in order to prove that the
   values calculated for

   QOut

    are actually passed to *sim*:

   >>> from hydpy import IntegrationTest
   >>> IntegrationTest.plotting_options.activated=(
   ...     fluxes.qin, fluxes.qout)
   >>> test = IntegrationTest(
   ...     stream,
   ...     seqs=(fluxes.qin, fluxes.qpin, fluxes.qpout,
   ...           fluxes.qout, nodes.output.sequences.sim))

   To start the respective example runs from stationary conditions, a
   base flow value of 2 mÂ³/s is set for all values of the log
   sequences

   LogIn

    and

   LogOut

   :

   >>> test.inits = ((logs.login, 2.),
   ...               (logs.logout, 2.))

   Print just the time instead of the whole date:

   >>> test.dateformat = '%H:%M'

   Define two flood events, one for each lake inflow:

   >>> nodes.input1.sequences.sim.series = (
   ...     1., 1., 2., 4., 3., 2., 1., 1., 1., 1.,
   ...     1., 1., 1., 1., 1., 1., 1., 1., 1., 1.)
   >>> nodes.input2.sequences.sim.series = (
   ...     1., 2., 6., 9., 8., 6., 4., 3., 2., 1.,
   ...     1., 1., 1., 1., 1., 1., 1., 1., 1., 1.)

   In the first example, a pure fourth order moving avarage (MA)
   process is defined via the control parameter

   Responses

   :

   >>> responses(((), (0.2, 0.4, 0.3, 0.1)))

   This leads to a usual "unit hydrograph" convolution result, where
   all inflow "impulses" are separated onto the actual and the three
   subsequent time steps:

   >>> test('arma_v1_ex1')
   |  date |  qin | qpin | qpout | qout | output |
   -----------------------------------------------
   | 00:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 01:00 |  3.0 |  3.0 |   2.2 |  2.2 |    2.2 |
   | 02:00 |  8.0 |  8.0 |   3.6 |  3.6 |    3.6 |
   | 03:00 | 13.0 | 13.0 |   6.9 |  6.9 |    6.9 |
   | 04:00 | 11.0 | 11.0 |  10.1 | 10.1 |   10.1 |
   | 05:00 |  8.0 |  8.0 |  10.7 | 10.7 |   10.7 |
   | 06:00 |  5.0 |  5.0 |   8.8 |  8.8 |    8.8 |
   | 07:00 |  4.0 |  4.0 |   6.3 |  6.3 |    6.3 |
   | 08:00 |  3.0 |  3.0 |   4.5 |  4.5 |    4.5 |
   | 09:00 |  2.0 |  2.0 |   3.3 |  3.3 |    3.3 |
   | 10:00 |  2.0 |  2.0 |   2.5 |  2.5 |    2.5 |
   | 11:00 |  2.0 |  2.0 |   2.1 |  2.1 |    2.1 |
   | 12:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 13:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 14:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 15:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 16:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 17:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 18:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
   | 19:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |

   In the second example, the mimimum order of the MA process is
   defined, which is one.  The autoregression (AR) process is of order
   two.  Note that negative AR coefficients are allowed (also note the
   opposite signs of the coefficients in contrast to the statistical
   literature):

   >>> responses(((1.1, -0.3), (0.2,)))

   Due to the AR process, the maximum time delay of some fractions of
   each input impulse is theoretically infinite:

   >>> test('arma_v1_ex2')
   |  date |  qin | qpin |    qpout |     qout |   output |
   --------------------------------------------------------
   | 00:00 |  2.0 |  2.0 |      2.0 |      2.0 |      2.0 |
   | 01:00 |  3.0 |  3.0 |      2.2 |      2.2 |      2.2 |
   | 02:00 |  8.0 |  8.0 |     3.42 |     3.42 |     3.42 |
   | 03:00 | 13.0 | 13.0 |    5.702 |    5.702 |    5.702 |
   | 04:00 | 11.0 | 11.0 |   7.4462 |   7.4462 |   7.4462 |
   | 05:00 |  8.0 |  8.0 |  8.08022 |  8.08022 |  8.08022 |
   | 06:00 |  5.0 |  5.0 | 7.654382 | 7.654382 | 7.654382 |
   | 07:00 |  4.0 |  4.0 | 6.795754 | 6.795754 | 6.795754 |
   | 08:00 |  3.0 |  3.0 | 5.779015 | 5.779015 | 5.779015 |
   | 09:00 |  2.0 |  2.0 |  4.71819 |  4.71819 |  4.71819 |
   | 10:00 |  2.0 |  2.0 | 3.856305 | 3.856305 | 3.856305 |
   | 11:00 |  2.0 |  2.0 | 3.226478 | 3.226478 | 3.226478 |
   | 12:00 |  2.0 |  2.0 | 2.792235 | 2.792235 | 2.792235 |
   | 13:00 |  2.0 |  2.0 | 2.503515 | 2.503515 | 2.503515 |
   | 14:00 |  2.0 |  2.0 | 2.316196 | 2.316196 | 2.316196 |
   | 15:00 |  2.0 |  2.0 | 2.196761 | 2.196761 | 2.196761 |
   | 16:00 |  2.0 |  2.0 | 2.121578 | 2.121578 | 2.121578 |
   | 17:00 |  2.0 |  2.0 | 2.074708 | 2.074708 | 2.074708 |
   | 18:00 |  2.0 |  2.0 | 2.045705 | 2.045705 | 2.045705 |
   | 19:00 |  2.0 |  2.0 | 2.027863 | 2.027863 | 2.027863 |

   The third example equals the second one, except in the additional
   time delay of exactly one hour, due to the changed MA process:

   >>> responses(((1.1, -0.3), (0.0, 0.2)))

   >>> test('arma_v1_ex3')
   |  date |  qin | qpin |    qpout |     qout |   output |
   --------------------------------------------------------
   | 00:00 |  2.0 |  2.0 |      2.0 |      2.0 |      2.0 |
   | 01:00 |  3.0 |  3.0 |      2.0 |      2.0 |      2.0 |
   | 02:00 |  8.0 |  8.0 |      2.2 |      2.2 |      2.2 |
   | 03:00 | 13.0 | 13.0 |     3.42 |     3.42 |     3.42 |
   | 04:00 | 11.0 | 11.0 |    5.702 |    5.702 |    5.702 |
   | 05:00 |  8.0 |  8.0 |   7.4462 |   7.4462 |   7.4462 |
   | 06:00 |  5.0 |  5.0 |  8.08022 |  8.08022 |  8.08022 |
   | 07:00 |  4.0 |  4.0 | 7.654382 | 7.654382 | 7.654382 |
   | 08:00 |  3.0 |  3.0 | 6.795754 | 6.795754 | 6.795754 |
   | 09:00 |  2.0 |  2.0 | 5.779015 | 5.779015 | 5.779015 |
   | 10:00 |  2.0 |  2.0 |  4.71819 |  4.71819 |  4.71819 |
   | 11:00 |  2.0 |  2.0 | 3.856305 | 3.856305 | 3.856305 |
   | 12:00 |  2.0 |  2.0 | 3.226478 | 3.226478 | 3.226478 |
   | 13:00 |  2.0 |  2.0 | 2.792235 | 2.792235 | 2.792235 |
   | 14:00 |  2.0 |  2.0 | 2.503515 | 2.503515 | 2.503515 |
   | 15:00 |  2.0 |  2.0 | 2.316196 | 2.316196 | 2.316196 |
   | 16:00 |  2.0 |  2.0 | 2.196761 | 2.196761 | 2.196761 |
   | 17:00 |  2.0 |  2.0 | 2.121578 | 2.121578 | 2.121578 |
   | 18:00 |  2.0 |  2.0 | 2.074708 | 2.074708 | 2.074708 |
   | 19:00 |  2.0 |  2.0 | 2.045705 | 2.045705 | 2.045705 |

   Be aware that neither parameter

   Responses

    does check the assigned coefficients nor does model

   arma_v1

    check the calculated outflow for plausibility (one can use the
   features provided in modules

   iuhtools

    and

   armatools

    to calculate reliable coefficients). The fourth example increases
   the span of the AR coefficients used in the third example.  The
   complete ARMA process is still mass conservative, but some response
   values of the recession curve are negative:

   >>> responses(((1.5, -0.7), (0.0, 0.2)))
   >>> test('arma_v1_ex4')
   |  date |  qin | qpin |     qpout |      qout |    output |
   -----------------------------------------------------------
   | 00:00 |  2.0 |  2.0 |       2.0 |       2.0 |       2.0 |
   | 01:00 |  3.0 |  3.0 |       2.0 |       2.0 |       2.0 |
   | 02:00 |  8.0 |  8.0 |       2.2 |       2.2 |       2.2 |
   | 03:00 | 13.0 | 13.0 |       3.5 |       3.5 |       3.5 |
   | 04:00 | 11.0 | 11.0 |      6.31 |      6.31 |      6.31 |
   | 05:00 |  8.0 |  8.0 |     9.215 |     9.215 |     9.215 |
   | 06:00 |  5.0 |  5.0 |   11.0055 |   11.0055 |   11.0055 |
   | 07:00 |  4.0 |  4.0 |  11.05775 |  11.05775 |  11.05775 |
   | 08:00 |  3.0 |  3.0 |  9.682775 |  9.682775 |  9.682775 |
   | 09:00 |  2.0 |  2.0 |  7.383738 |  7.383738 |  7.383738 |
   | 10:00 |  2.0 |  2.0 |  4.697664 |  4.697664 |  4.697664 |
   | 11:00 |  2.0 |  2.0 |  2.277879 |  2.277879 |  2.277879 |
   | 12:00 |  2.0 |  2.0 |  0.528454 |  0.528454 |  0.528454 |
   | 13:00 |  2.0 |  2.0 | -0.401834 | -0.401834 | -0.401834 |
   | 14:00 |  2.0 |  2.0 | -0.572669 | -0.572669 | -0.572669 |
   | 15:00 |  2.0 |  2.0 |  -0.17772 |  -0.17772 |  -0.17772 |
   | 16:00 |  2.0 |  2.0 |  0.534289 |  0.534289 |  0.534289 |
   | 17:00 |  2.0 |  2.0 |  1.325837 |  1.325837 |  1.325837 |
   | 18:00 |  2.0 |  2.0 |  2.014753 |  2.014753 |  2.014753 |
   | 19:00 |  2.0 |  2.0 |  2.494044 |  2.494044 |  2.494044 |

   In the fifth example, the coefficients of the first two examples
   are combined.  For inflow discharges between 0 and 7 mÂ³/s, the pure
   AR process is applied.  For inflow discharges exceeding 7 mÂ³/s,
   inflow is separated.  The AR process is still applied on a portion
   of 7 mÂ³/s, but for the inflow exceeding the threshold the mixed
   ARMA model is applied:

   >>> responses(_0=((), (0.2, 0.4, 0.3, 0.1)),
   ...           _7=((1.1, -0.3), (0.2,)))

   To again start from stationary conditions, one has to apply
   different values to both log sequences.  The base flow value of 2
   mÂ³/s is only given to the (low flow) MA model, the (high flow) ARMA
   model is initialized with zero values instead:

   >>> test.inits.login = [[2.0], [0.0]]
   >>> test.inits.logout = [[2.0], [0.0]]

   The separate handling of the inflow can be studied by inspecting
   the columns of sequence

   QPIn

    and sequence

   QPOut

   .  The respective left columns show the input and output of the MA
   model, the respective right colums show the input and output of the
   ARMA model:

   >>> test('arma_v1_ex5')
   |  date |  qin |      qpin |         qpout |     qout |   output |
   ------------------------------------------------------------------
   | 00:00 |  2.0 | 2.0   0.0 | 2.0       0.0 |      2.0 |      2.0 |
   | 01:00 |  3.0 | 3.0   0.0 | 2.2       0.0 |      2.2 |      2.2 |
   | 02:00 |  8.0 | 7.0   1.0 | 3.4       0.2 |      3.6 |      3.6 |
   | 03:00 | 13.0 | 7.0   6.0 | 5.3      1.42 |     6.72 |     6.72 |
   | 04:00 | 11.0 | 7.0   4.0 | 6.6     2.302 |    8.902 |    8.902 |
   | 05:00 |  8.0 | 7.0   1.0 | 7.0    2.3062 |   9.3062 |   9.3062 |
   | 06:00 |  5.0 | 5.0   0.0 | 6.6   1.84622 |  8.44622 |  8.44622 |
   | 07:00 |  4.0 | 4.0   0.0 | 5.6  1.338982 | 6.938982 | 6.938982 |
   | 08:00 |  3.0 | 3.0   0.0 | 4.4  0.919014 | 5.319014 | 5.319014 |
   | 09:00 |  2.0 | 2.0   0.0 | 3.3  0.609221 | 3.909221 | 3.909221 |
   | 10:00 |  2.0 | 2.0   0.0 | 2.5  0.394439 | 2.894439 | 2.894439 |
   | 11:00 |  2.0 | 2.0   0.0 | 2.1  0.251116 | 2.351116 | 2.351116 |
   | 12:00 |  2.0 | 2.0   0.0 | 2.0  0.157896 | 2.157896 | 2.157896 |
   | 13:00 |  2.0 | 2.0   0.0 | 2.0  0.098351 | 2.098351 | 2.098351 |
   | 14:00 |  2.0 | 2.0   0.0 | 2.0  0.060817 | 2.060817 | 2.060817 |
   | 15:00 |  2.0 | 2.0   0.0 | 2.0  0.037394 | 2.037394 | 2.037394 |
   | 16:00 |  2.0 | 2.0   0.0 | 2.0  0.022888 | 2.022888 | 2.022888 |
   | 17:00 |  2.0 | 2.0   0.0 | 2.0  0.013959 | 2.013959 | 2.013959 |
   | 18:00 |  2.0 | 2.0   0.0 | 2.0  0.008488 | 2.008488 | 2.008488 |
   | 19:00 |  2.0 | 2.0   0.0 | 2.0  0.005149 | 2.005149 | 2.005149 |

class hydpy.models.arma_v1.Model

   Bases:

   hydpy.core.modeltools.Model

   Rimo/Rido version of ARMA (arma_v1).

   The following "run methods" are called each simulation step run in
   the given sequence:
      calc_qpin_v1() Calculate the input discharge portions of the
      different response functions.

      calc_login_v1() Refresh the input log sequence for the different
      MA processes.

      calc_qma_v1() Calculate the discharge responses of the different
      MA processes.

      calc_qar_v1() Calculate the discharge responses of the different
      AR processes.

      calc_qpout_v1() Calculate the ARMA results for the different
      response functions.

      calc_logout_v1() Refresh the log sequence for the different AR
      processes.

      calc_qout_v1() Sum up the results of the different response
      functions.

   The following "inlet update methods" are called in the given
   sequence immediately  before solving the differential equations of
   the respective model:
      pick_q_v1() Update inflow.

   The following "outlet update methods" are called in the given
   sequence immediately  after solving the differential equations of
   the respective model:
      pass_q_v1() Update outflow.

class hydpy.models.arma_v1.ControlParameters(pars, cls_fastaccess=None, cymodel=None)

   Bases:

   hydpy.core.parametertools.SubParameters

   Control parameters of arma_v1, directly defined by the user.

   The following parameter classes are selected:
      Responses Assigns different ARMA models to different discharge
      thresholds.

class hydpy.models.arma_v1.DerivedParameters(pars, cls_fastaccess=None, cymodel=None)

   Bases:

   hydpy.core.parametertools.SubParameters

   Derived parameters of arma_v1, indirectly defined by the user.

   The following parameter classes are selected:
      Nmb Number of response functions [-].

      MaxQ Maximum discharge values of the respective ARMA models
      [mÂ³/s].

      DiffQ Differences between the values of MaxQ [mÂ³/s].

      AR_Order Number of AR coefficients of the different responses
      [-].

      MA_Order Number of MA coefficients of the different responses
      [-].

      AR_Coefs AR coefficients of the different responses [-].

      MA_Coefs MA coefficients of the different responses [-].

class hydpy.models.arma_v1.FluxSequences(seqs, cls_fastaccess=None, cymodel=None)

   Bases:

   hydpy.core.sequencetools.FluxSequences

   Flux sequences of arma_v1

   The following sequence classes are selected:
      QIn Total inflow [mÂ³/s].

      QPIn Inflow portions corresponding to the different thresholds
      [mÂ³/s].

      QMA MA result for the different thresholds [mÂ³/s].

      QAR AR result for the different thresholds [mÂ³/s].

      QPOut Outflow portions corresponding to the different thresholds
      [mÂ³/s].

      QOut Total outflow [mÂ³/s].

class hydpy.models.arma_v1.LogSequences(seqs, cls_fastaccess=None, cymodel=None)

   Bases:

   hydpy.core.sequencetools.LogSequences

   Log sequences of arma_v1.

   The following sequence classes are selected:
      LogIn The recent and the past inflow portions for the
      application of the different MA processes [mÂ³/s].

      LogOut The past outflow portions for the application of the
      different AR processes [mÂ³/s].

class hydpy.models.arma_v1.InletSequences(seqs, cls_fastaccess=None, cymodel=None)

   Bases:

   hydpy.core.sequencetools.LinkSequences

   Upstream link sequences of arma_v1.

   The following sequence classes are selected:
      Q Runoff [mÂ³/s].

class hydpy.models.arma_v1.OutletSequences(seqs, cls_fastaccess=None, cymodel=None)

   Bases:

   hydpy.core.sequencetools.LinkSequences

   Downstream link sequences of arma_v1.

   The following sequence classes are selected:
      Q Runoff [mÂ³/s].
