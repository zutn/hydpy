exceptiontools

This module implements some exception classes and related features.

Module

exceptiontools

 implements the following members:

   AttributeNotReady The attribute is principally defined, but must be
   prepared first.

   IsReady Container that informs, whether all variables required in a
   certain context are properly prepared or not.

   protected_property() Return a property which prevents getting an
   attribute before setting it.

   dependent_property() Return a property which prevents accessing a
   dependent attribute before other attributes have been prepared.

   OptionalModuleNotAvailable A HydPy function requiring an optional
   module is called, but this module is not available.

   OptionalImport Exectutes the given import command and returns the
   imported module. If importomg is not possible, it returns a dummy
   object which raises a OptionalModuleNotAvailable each time a one
   tries to access a member of the orignal module.


exception hydpy.core.exceptiontools.AttributeNotReady

   Bases:

   AttributeError

   The attribute is principally defined, but must be prepared first.

class hydpy.core.exceptiontools.IsReady(true=(), false=())

   Bases:

   object

   Container that informs, whether all variables required in a certain
   context are properly prepared or not.

   All variables can start with a *True* or *False* value:

   >>> from hydpy.core.exceptiontools import IsReady
   >>> isready = IsReady(true=['x', 'y'], false=['z'])
   >>> isready.x
   True
   >>> isready.z
   False

   If there is at least one *False* value, the

   IsReady

    object itself is considered to be *False*:

   >>> isready
   IsReady(true=['x', 'y'],
           false=['z'])
   >>> bool(isready)
   False

   Only in case all values are *True*, *isready* is considered to the
   *True*:

   >>> isready.z = True
   >>> isready
   IsReady(true=['x', 'y', 'z'],
           false=[])
   >>> bool(isready)
   True

   true

      Sorted tuple of the names of all *True* variables.

      >>> from hydpy.core.exceptiontools import IsReady
      >>> isready = IsReady(true=['b', 'c', 'a'], false=['z'])
      >>> isready.true
      ('a', 'b', 'c')

   false

      Sorted tuple of the names of all *False* variables.

      >>> from hydpy.core.exceptiontools import IsReady
      >>> isready = IsReady(false=['b', 'c', 'a'], true=['z'])
      >>> isready.false
      ('a', 'b', 'c')

hydpy.core.exceptiontools.protected_property(propname, fget, fset=None, fdel=None)

   Return a

   property

    which prevents getting an attribute before setting it.

   Under some circumstances, an attribute value needs to be prepared
   before one should be allowed to query it.  Consider the case where
   a property of a Python class (beeing part of the API) links to an
   attribute of a Cython extension class (not part of the API).  If
   the Cython attribute is e.g. some type of vector requiring memory
   allocation, trying to query this vector befor it has actually been
   prepared results in a programm crash.  Using

   protected_property()

    is a means to prevent from such problems to occur.

   Consider the following class *Test*, which defines most simple
   *set*, *get*, and *del* methods for its only property *x*:

   >>> from hydpy.core.exceptiontools import IsReady, protected_property
   >>> class Test(object):
   ...
   ...     def __init__(self):
   ...         self._x = None
   ...         self._isready = IsReady(false=['x'])
   ...
   ...     def _get_x(self):
   ...         return self._x
   ...
   ...     def _set_x(self, value):
   ...         self._x = value
   ...
   ...     def _del_x(self):
   ...         self._x = None
   ...
   ...     x = protected_property(
   ...         'x', _get_x, _set_x, _del_x)

   Due to using

   protected_property()

    instead of

   property

   , trying to query *x* after initializing a *Test* object results in
   an

   AttributeNotReady

    error:

   >>> test = Test()
   >>> test.x
   Traceback (most recent call last):
   ...
   AttributeNotReady: Attribute `x` of object `test` has not been prepared so far.

   After setting a value for property *x*, this value can be queried
   as expected:

   >>> test.x = 1
   >>> test.x
   1

   After deleting *x*, its valu is not accessible, again:

   >>> del test.x
   >>> test.x
   Traceback (most recent call last):
   ...
   AttributeNotReady: Attribute `x` of object `test` has not been prepared so far.

   If the considered object defines a name (different from the class
   name in lower letters) and/or references a

   Node

    or

   Element

    object, the exception message includes this additional
   information:

   >>> from hydpy import Element
   >>> test.name = 'name_object'
   >>> test.element = Element('name_element')

   >>> test.x
   Traceback (most recent call last):
   ...
   AttributeNotReady: Attribute `x` of object `name_object` of element `name_element` has not been prepared so far.

   As for

   property

   , the *set* and *del* can be omitted.  As an example, we redefine
   class *Test* with a *get* method only:

   >>> class Test(object):
   ...
   ...     def __init__(self):
   ...         self._x = None
   ...         self._isready = IsReady(false=['x'])
   ...
   ...     def _get_x(self):
   ...         return self._x
   ...
   ...     x = protected_property(
   ...         'x', _get_x)
   >>> test = Test()

   Now trying to set a new value results in the usual error...

   >>> test.x = 1
   Traceback (most recent call last):
   ...
   AttributeError: cannot set attribute

   ...and does not change the value of attribute *x*:

   >>> test.x
   Traceback (most recent call last):
   ...
   AttributeNotReady: Attribute `x` of object `test` has not been prepared so far.

   The same holds true for trying to delete the value of attribute
   *x*:

   >>> del test.x
   Traceback (most recent call last):
   ...
   AttributeError: cannot delete attribute

   Note: The class making use of

     protected_property()

      must implement an

     IsReady

      member as shown in the example.  The member name *_isready* is
     mandatory.

hydpy.core.exceptiontools.dependent_property(propname, fget, fset=None, fdel=None)

   Return a

   property

    which prevents accessing a dependent attribute before other
   attributes have been prepared.

   The following explanations suppose first reading the documentation
   on function

   protected_property()

   .  Here the example class *Test* is defined very similarly, but *x*
   is returned by

   dependent_property()

    instead of

   protected_property()

   , and the

   IsReady

    member knows another attribute *y* but not the dependent attribute
   *x* (usually but not mandatory, *y* itself would be implemented as
   a

   protected_property()

   , which is left out for reasons of brevity):

   >>> from hydpy.core.exceptiontools import IsReady, protected_property
   >>> from hydpy.core.exceptiontools import dependent_property
   >>> class Test(object):
   ...
   ...     def __init__(self):
   ...         self._x = None
   ...         self._isready = IsReady(false=['y'])
   ...
   ...     def _get_x(self):
   ...         return self._x
   ...
   ...     def _set_x(self, value):
   ...         self._x = value
   ...
   ...     def _del_x(self):
   ...         self._x = None
   ...
   ...     x = dependent_property(
   ...         'x', _get_x, _set_x, _del_x)

   Initially, due to *y* beeing not prepared according to *_isready*,
   there is no way to get, set, or delete attribute *x*:

   >>> test = Test()
   >>> test.x
   Traceback (most recent call last):
   ...
   AttributeNotReady: Attribute `x` of object `test` is not usable so far.

   >>> test.x = 1
   Traceback (most recent call last):
   ...
   AttributeNotReady: Attribute `x` of object `test` is not usable so far.

   >>> del test.x
   Traceback (most recent call last):
   ...
   AttributeNotReady: Attribute `x` of object `test` is not usable so far.

   However, after setting the *y* flag to *True*, *x* behaves like a
   "normal" property:

   >>> test._isready.y = True
   >>> test.x = 1
   >>> test.x
   1
   >>> del test.x
   >>> test.x

exception hydpy.core.exceptiontools.OptionalModuleNotAvailable

   Bases:

   ImportError

   A *HydPy* function requiring an optional module is called, but this
   module is not available.

class hydpy.core.exceptiontools.OptionalImport(command)

   Bases:

   object

   Exectutes the given import command and returns the imported module.
   If importomg is not possible, it returns a dummy object which
   raises a

   OptionalModuleNotAvailable

    each time a one tries to access a member of the orignal module.

   If the module is availabe:

   >>> from hydpy.core.exceptiontools import OptionalImport
   >>> numpy = OptionalImport('import numpy')
   >>> numpy.nan
   nan

   If the module is not available:

   >>> numpie = OptionalImport('import numpie')
   >>> numpie.nan
   Traceback (most recent call last):
   ...
   OptionalModuleNotAvailable: HydPy could not load module `numpie`.  This module is no general requirement but necessary for some specific functionalities.

   If the module is available, but HydPy had been bundled to an
   executable:

   >>> from hydpy import pub
   >>> pub._is_hydpy_bundled = True
   >>> os = OptionalImport('import os')
   >>> os.getcwd()
   Traceback (most recent call last):
   ...
   OptionalModuleNotAvailable: HydPy could not load module `os`.  This module is no general requirement but necessary for some specific functionalities.

   The latter can be prevented by passing a *True* *bundle_module*
   argument:

   >>> textwrap = OptionalImport('import textwrap', bundle_module=True)
   >>> textwrap.wrap('')
   []

   >>> pub._is_hydpy_bundled = False
