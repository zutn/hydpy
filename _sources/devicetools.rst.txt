devicetools

This modules implements features related to two types of *devices*,
called *nodes* and *elements* which are the most fundamental means to
structure HydPy projects.

Module

devicetools

 implements the following members:

   Keywords Set of keyword arguments used to describe and search for
   element and node objects.

   Device Base class for class Element and class Node.

   Node Handles the data flow between Element objects.

   Element Handles a Model and connects it to other models via Node
   objects.

   Devices Base class for class Elements and class Nodes.

   Nodes A container for handling Node objects.

   Elements A container for handling Element objects.


class hydpy.core.devicetools.Keywords(names=None)

   Bases:

   set

   Set of keyword arguments used to describe and search for element
   and node objects.

   >>> from hydpy.core.devicetools import Keywords
   >>> from hydpy import dummies
   >>> dummies.keywords = Keywords(['first_keyword', 'second_keyword',
   ...                              'keyword_3', 'keyword_4',
   ...                              'keyboard'])
   >>> dummies.keywords
   Keywords(["first_keyword", "keyboard", "keyword_3", "keyword_4",
             "second_keyword"])

   startswith(name)

      Returns a list of all keywords starting with the given string.

      >>> from hydpy import dummies
      >>> dummies.keywords.startswith('keyword')
      ['keyword_3', 'keyword_4']

   endswith(name)

      Returns a list of all keywords ending with the given string.

      >>> from hydpy import dummies
      >>> dummies.keywords.endswith('keyword')
      ['first_keyword', 'second_keyword']

   contains(name)

      Returns a list of all keywords containing the given string.

      >>> from hydpy import dummies
      >>> dummies.keywords.contains('keyword')
      ['first_keyword', 'keyword_3', 'keyword_4', 'second_keyword']

   update(names)

      Before updating, names are checked to be valid variable
      identifiers.

      >>> from hydpy import dummies
      >>> keywords = dummies.keywords
      >>> keywords.update(['test_1', 'test 2'])
      Traceback (most recent call last):
      ...
      ValueError: While trying to add the keyword `test 2` to device `?`, the following error occured: The given name string `test 2` does not define a valid variable identifier.  ...

      Note that the first string (*test_1*) is not added, as the
      second one (*test 2*) is invalid:

      >>> keywords
      Keywords(["first_keyword", "keyboard", "keyword_3", "keyword_4",
                "second_keyword"])

      If the seconds string is corrected, everything works fine:

      >>> keywords.update(['test_1', 'test_2'])
      >>> keywords
      Keywords(["first_keyword", "keyboard", "keyword_3", "keyword_4",
                "second_keyword", "test_1", "test_2"])

   add(name)

      Before adding a new name, it is checked to be valid variable
      identifiers.

      >>> from hydpy import dummies
      >>> keywords = dummies.keywords
      >>> keywords.add('1_test')
      Traceback (most recent call last):
      ...
      ValueError: While trying to add the keyword `1_test` to device `?`, the following error occured: The given name string `1_test` does not define a valid variable identifier.  ...

      >>> keywords
      Keywords(["first_keyword", "keyboard", "keyword_3", "keyword_4",
                "second_keyword"])

      If the string is corrected, everything works fine:

      >>> keywords.add('one_test')
      >>> keywords
      Keywords(["first_keyword", "keyboard", "keyword_3", "keyword_4",
                "one_test", "second_keyword"])

class hydpy.core.devicetools.Device

   Bases:

   object

   Base class for class

   Element

    and class

   Node

   .

   For framework programmers it is important to know, that all created
   devices are registered.  Besides some other simplifications for
   framework users, this prevents from defining multiple devices with
   the same name (which is not allowed, at the names are supposed to
   be valid object identifiers).

   To show how the registry works, we first start with a clear
   registry:

   >>> from hydpy import Node
   >>> Node.clear_registry()
   >>> sorted(Node.registered_names())
   []

   Now we initialize two nodes:

   >>> node1 = Node('n1')
   >>> node2 = Node('n2')

   Each time we pass the same names to the constructor of class

   Node

   , the same object is returned:

   >>> node1 is Node('n1')
   True
   >>> node1 is Node('n2')
   False

   You can access all registed nodes via the following class method:

   >>> Node.registered_nodes()
   Nodes("n1", "n2")

   The respective names are directly available via:

   >>> sorted(Node.registered_names())
   ['n1', 'n2']

   It is not recommended under usual circumstances, but you are
   allowed to clear the registry:

   >>> Node.clear_registry()
   >>> Node.registered_nodes()
   Nodes()

   But now there is the danger of creating two differnt nodes with the
   same name, which is very likely to result in strange bugs:

   >>> new_node1 = Node('n1')
   >>> new_node1 is node1
   False
   >>> new_node1 == node1
   True

   The examples above also work for class

   Element

   , except that method

   registered_nodes()

    must be exchanged with method

   registered_elements()

   , of course:

   >>> from hydpy import Element
   >>> Element.clear_registry()
   >>> Element('e1').registered_elements()
   Elements("e1")

   name

      Name of the actual device (node or element).

      Names are the identifiers of

      Node

       and

      Element

       objects. So define them carefully:

      >>> from hydpy import Node
      >>> node1, node2 = Node('n1'), Node('n2')
      >>> node1 is Node('n1')
      True
      >>> node1 is Node('n2')
      False

      Note that each name name must be a valid variable identifier
      (see function

      valid_variable_identifier()

      ), to allow for attribute access:

      >>> from hydpy import Nodes
      >>> nodes = Nodes(node1, 'n2')
      >>> nodes.n1
      Node("n1", variable="Q")

      Invalid variable identifiers result errors like the following:

      >>> node3 = Node('n 3')
      Traceback (most recent call last):
      ...
      ValueError: While trying to initialize a `Node` object with value `n 3` of type `str`, the following error occured: The given name string `n 3` does not define a valid variable identifier.  ...

      When you change the name of a

      Node

       and

      Element

       object (only do this for a good reason), the corresponding key
      of all related

      Nodes

       and

      Elements

       objects (as well as of the internal registry) changes
      automatically:

      >>> node1.name = 'n1a'
      >>> nodes
      Nodes("n1a", "n2")

   keywords

      Keywords describing this device.

      The keywords are contained within a

      Keywords

       object:

      >>> from hydpy import Node
      >>> node = Node('n')
      >>> node.keywords
      Keywords([])

      You are allowed to add then individually...

      >>> node.keywords = 'word1'

      ... or within iterables:

      >>> node.keywords = ('word2', 'word3')
      >>> node.keywords
      Keywords(["word1", "word2", "word3"])

      You can delete all keywords at once via:

      >>> del node.keywords
      >>> node.keywords
      Keywords([])

   classmethod clear_registry()

      Clear the registry from all initialized devices.

   classmethod registered_names()

      Get all names of

      Device

       objects initialized so far.

   add_handler(handler)

      Add the given handler (either an

      Elements

       or :class`Nodes` object) to the set of handlers stored
      internally.

   remove_handler(handler)

      Remove the given handler (either an

      Elements

       or :class`Nodes` object) from the set of handlers stored
      internally.

class hydpy.core.devicetools.Node(name, variable=None, keywords=None)

   Bases:

   hydpy.core.devicetools.Device

   Handles the data flow between

   Element

    objects.

   When initializing

   Node

    objects, values for the optional *variable* and *keywords* can be
   passed, which default to *Q* and "empty:

   >>> from hydpy import Node
   >>> node = Node('test')
   >>> node.variable
   'Q'
   >>> node.keywords
   Keywords([])

   You are allowed to add further keywords by successive constructor
   calls:

   >>> node = Node('test', keywords='word1')
   >>> Node('test', keywords=('word2', 'word3'))
   Node("test", variable="Q",
        keywords=["word1", "word2", "word3"])

   But you are not allowed to change the variable a node is supposed
   to handle (would be to error-prone):

   >>> Node('test', variable='W')
   Traceback (most recent call last):
   ...
   ValueError: The variable to be represented by a `Node instance cannot be changed.  The variable of node `test` is `Q` instead of `W` or `None`.  Keep in mind, that `name` is the unique identifier of node objects.

   If you really want to change a variable without to restart your
   Python process, you have to delete the node from the registry first
   (again, very error-prone unless you are absolutely sure you can
   delete all other relevant references to the node object):

   >>> del node._registry['test']
   >>> Node('test', variable='W')
   Node("test", variable="W")

   To fully understand the last example, read the technical remarks
   regarding the registry of

   Device

    objects explained above. On top of this persistent registry, there
   is also a temporal one, which helps to identify when certain nodes
   where created (e.g. during the execution of a certain network
   file).

   To show how this works, we again start with a clear registry:

   >>> Node.clear_registry()

   Firstly, create two nodes:

   >>> node1 = Node('n1')
   >>> node2 = Node('n2')

   Now "gather" these two nodes:

   >>> Node.gather_new_nodes()
   Nodes("n1", "n2")

   This automatically removes the gathered nodes from the temporal
   registry. This can be shown by simply calling the method again:

   >>> Node.gather_new_nodes()
   Nodes()

   Now create a new node (n3) and call the constructor of an already
   existing node again:

   >>> node3 = Node('n3')
   >>> node1 = Node('n1')

   Calling method *gather_new_nodes* again shows that an node is
   regarded as "new", if its constructor has been called:

   >>> Node.gather_new_nodes()
   Nodes("n1", "n3")

   This mechanism allows for redefining the same node in different
   network files while keeping track of all files where it has been
   defined.

   The following example is just supposed to clarify that the
   permanent registry has not been altered by calling
   *gather_new_nodes*:

   >>> Node.registered_nodes()
   Nodes("n1", "n2", "n3")

   variable

      The variable handled by the respective node instance, e.g. *Q*.

   classmethod registered_nodes()

      Get all

      Node

       objects initialized so far.

   classmethod gather_new_nodes()

      Gather all *new*

      Node

       objects.

      Node

       objects are deemed to be new if they have been created after
      the last usage of this method.

   deploymode

      Defines the kind of information a node deploys.

      The following modes are supported:

         newsim: Deploy the simulated values calculated just recently.
         This is the default mode, where a node receives e.g. a
         discharge value from a upstream element and passes it to the
         downstream element directly.

         obs: Deploy observed values instead of simulated values.  The
         node still receives the simulated values from its upstream
         element(s).  But it deploys values to its downstream nodes
         which are defined externally.  Usually, these values are
         observations made available within an Sequence file. See
         module sequencetools for further information on file
         specifications.

         oldsim: Simular to mode obs.  But it is usually applied when
         a node is supposed to deploy simulated values which have been
         calculated in a previous simulation run and stored in a
         sequence file.

      The technical difference between modes *obs* and *oldsim* is,
      that the external values are either handled by the *obs* or the
      *sim* sequence object.  Hence, if you select the *oldsim* mode,
      the values of the upstream elements calculated within the
      current simulation are not available (e.g. for parameter
      calibration) after the simulation is finished.

   get_double(group)

      Return the "Double" object appropriate for the given group and
      the predefined deploy mode.

      >>> from hydpy import Node
      >>> node = Node('node1')
      >>> node.sequences.sim = 1.0
      >>> node.sequences.obs = 2.0
      >>> def test(deploymode):
      ...     node.deploymode = deploymode
      ...     for group in ('inlets', 'receivers', 'outlets', 'senders'):
      ...         print(node.get_double(group), end='')
      ...         if group != 'senders':
      ...             print(end=' ')
      >>> test('newsim')
      1.0 1.0 1.0 1.0
      >>> test('obs')
      2.0 2.0 1.0 1.0
      >>> test('oldsim')
      1.0 1.0 0.0 0.0
      >>> node.get_double('test')
      Traceback (most recent call last):
      ...
      ValueError: Function `get_double` of class `Node` does not support the given group name `test`.

   get_double_via_exits()

      Return the "Double" object that is supposed to deploy its value
      to the downstream elements.

   get_double_via_entries()

      Return the "Double" object that is supposed to receive the
      value(s) of the upstream elements.

   reset(idx=None)

      Reset the actual value of the simulation sequence to zero.

   open_files(idx=0)

      Call method

      open_files()

       of the

      Sequences

       object handled (indirectly) by the actual

      Node

       object.

   close_files()

      Call method

      close_files()

       of the

      Sequences

       object handled (indirectly) by the actual

      Node

       object.

   prepare_allseries(ramflag=True)

      Prepare the series objects of both the *sim* and the *obs*
      sequence.

      Call this method before a simulation run, if you need access to
      the whole time series of the simulated and the observed series
      after the simulation run is finished.

      By default, the series are stored in RAM, which is the faster
      option.  If your RAM is limited, pass the *False* for function
      argument *ramflag* to store the series on disk.

   prepare_simseries(ramflag=True)

      Prepare the series object of the *sim* sequence.

      See method

      prepare_allseries()

       for further information.

   prepare_obsseries(ramflag=True)

      Prepare the series object of the *obs* sequence.

      See method

      prepare_allseries()

       for further information.

   plot_allseries(**kwargs)

      Plot the series of both the *sim* and (if available) the *obs*
      sequence.

   violinplot(logscale=True)

   assignrepr(prefix='')

      Defines the *visual appearence* of

      Node

       objects.

      You can pass a string which prefixes the string representation.

class hydpy.core.devicetools.Element(name, inlets=None, outlets=None, receivers=None, senders=None, keywords=None)

   Bases:

   hydpy.core.devicetools.Device

   Handles a

   Model

    and connects it to other models via

   Node

    objects.

   You are allowed to pass keywords to the constructor of class

   Element

   , as shown above for class

   Node

   .

   Additionally, you are allowed to pass different nodes (or names of
   nodes) by successive constructor calls, e.g.:

   >>> from hydpy import Element, Node
   >>> Element('test')
   Element("test")
   >>> Element('test',
   ...         inlets='in1',
   ...         outlets='out1',
   ...         receivers='rec1',
   ...         senders='sen1')
   Element("test",
           inlets="in1",
           outlets="out1",
           receivers="rec1",
           senders="sen1")
   >>> Element('test',
   ...         inlets=('in2', Node('in3')),
   ...         outlets=('out2', Node('out3')),
   ...         receivers=('rec2', Node('rec3')),
   ...         senders=('sen2', Node('sen3')))
   Element("test",
           inlets=["in1", "in2", "in3"],
           outlets=["out1", "out2", "out3"],
           receivers=["rec1", "rec2", "rec3"],
           senders=["sen1", "sen2", "sen3"])

   Reassigning some nodes does no harm:

   >>> Element('test',
   ...         inlets=('in2', Node('in3'), 'in4'),
   ...         outlets=('out2', Node('out3'), 'out4'),
   ...         receivers=('rec2', Node('rec3'), 'rec4'),
   ...         senders=('sen2', Node('sen3'), 'sen4'))
   Element("test",
           inlets=["in1", "in2", "in3", "in4"],
           outlets=["out1", "out2", "out3", "out4"],
           receivers=["rec1", "rec2", "rec3", "rec4"],
           senders=["sen1", "sen2", "sen3", "sen4"])

   But it is verified that an element does not handle the same node as
   an *input* and *output* node or as a *receiver* and a *sender*
   node:

   >>> Element('test', inlets='out1')
   Traceback (most recent call last):
   ...
   ValueError: For element `test`, the given inlet node `out1` is already defined as an outlet node, which is not allowed.

   >>> Element('test', outlets='in1')
   Traceback (most recent call last):
   ...
   ValueError: For element `test`, the given outlet node `in1` is already defined as an inlet node, which is not allowed.

   >>> Element('test', receivers='sen1')
   Traceback (most recent call last):
   ...
   ValueError: For element `test`, the given receiver node `sen1` is already defined as a sender node, which is not allowed.

   >>> Element('test', senders='rec1')
   Traceback (most recent call last):
   ...
   ValueError: For element `test`, the given sender node `rec1` is already defined as a receiver, node which is not allowed.

   Note the technical remarks regarding the permanent registry of

   Device

    objects explained above (which also help to understand how the
   last examples work behind the scenes.)  Additionally, the remarks
   on the temperal registry of

   Node

    objects also apply on

   Element

    objects.  Without to repeat the whole explanation, this can be
   shown by the following short example:

   >>> from hydpy import Elements
   >>> Element.clear_registry()
   >>> Elements('e1', 'e2').e1.gather_new_elements()
   Elements("e1", "e2")
   >>> Elements('e3', 'e1').e1.gather_new_elements()
   Elements("e1", "e3")
   >>> Element.gather_new_elements()
   Elements()
   >>> Element.registered_elements()
   Elements("e1", "e2", "e3")

   classmethod registered_elements()

      Get all

      Element

       objects initialized so far.

   classmethod gather_new_elements()

      Gather all *new*

      Element

       objects.

      Element

       objects are deemed to be new if they have been created after
      the last usage of this method.

   variables

      A set of all different variables of the nodes directly connected
      to this element.

      Suppose there is a element connected to five nodes, which
      (partly) represent different variables:

      >>> from hydpy import Element, Node
      >>> element = Element('Test',
      ...                   inlets=(Node('N1', 'X'), Node('N2', 'Y1')),
      ...                   outlets=(Node('N3', 'X'), Node('N4', 'Y2')),
      ...                   receivers=(Node('N5', 'X'), Node('N6', 'Y3')),
      ...                   senders=(Node('N7', 'X'), Node('N8', 'Y4')))

      *variables* puts all the different variables of these nodes
      together:

      >>> sorted(element.variables)
      ['X', 'Y1', 'Y2', 'Y3', 'Y4']

   init_model(clear_registry=True)

      Load the control file of the actual

      Element

       object, initialize its

      Model

       object and build the required connections.

   connect(model=None)

      Connect the handled

      Model

       with the actual

      Element

       object.

      The following examples involve an error that is catched cleanly
      only in pure Python mode, hence Cython is disabled:

      >>> from hydpy import pub
      >>> pub.options.usecython = False

      If a model is passed, proper connections with this model are
      build We use the "HBV branch model"

      hbranch

       as an  example, which branches a single input value (from to
      node *inp*) to multiple outputs (nodes *out1* and *out2*):

      >>> from hydpy import Element, Node
      >>> element = Element('a_branch',
      ...                   inlets='branch_input',
      ...                   outlets=('branch_output_1', 'branch_output_2'))
      >>> inp = element.inlets.branch_input
      >>> out1, out2 = element.outlets
      >>> from hydpy.models.hbranch import *
      >>> parameterstep()
      >>> element.connect(model)

      To show that the inlet connection is built properly, assign a
      new value to the inlet node and verify that his value can
      actually be picked by the model:

      >>> inp.sequences.sim = 999.0
      >>> model.pick_input()
      >>> fluxes.input
      input(999.0)

      If no model is passed to method *connect*, the connections with
      the model already handled by this element are refreshed.  In the
      given example, the *hbranch* model could already le to connected
      to its inlet node, but not to its outlet nodes, which requires
      some parameter information on how to allocate the inflow to the
      different outlet nodes:

      >>> xpoints(0.0, 3.0)
      >>> ypoints(branch_output_1=[0.0, 1.0], branch_output_2=[0.0, 2.0])
      >>> parameters.update()
      >>> model.doit(0)
      Traceback (most recent call last):
      ...
      RuntimeError: The pointer of the acutal `PPDouble` instance at index 0 requested, but not prepared yet via `set_pointer`.

      The last command resulted in a somewhat strange error message.
      The reason for the explained error is that the *hbranch* model
      does now know how to connect to the outlet nodes *out1* and
      *out2*, but has not been requested to do so.  When we do so, no
      error is raised:

      >>> element.connect()
      >>> parameters.update()
      >>> model.doit(0)

      Now we can prove that both the inlet and the outlet connections
      are build properly by verifying that the expected output values
      are actually passed to the outlet nodes while performing an
      simulation step with method *doit* above:

      >>> out1.sequences.sim
      sim(333.0)
      >>> out2.sequences.sim
      sim(666.0)

      If neither a model is passed nor an model is already handled, an
      erro is raised:

      >>> Element('empty').connect()
      Traceback (most recent call last):
      ...
      AttributeError: While trying to build the connections of the model handled by element `empty`, the following error occured: No model has been assigned to the element so far.

   open_files(idx=0)

      Call method

      open_files()

       of the

      Sequences

       object handled (indirectly) by the actual

      Element

       object.

   close_files()

      Call method

      close_files()

       of the

      Sequences

       object handled (indirectly) by the actual

      Element

       object.

   prepare_allseries(ramflag=True)

      Prepare the series objects of all *input*, *flux* and *state*
      sequences of the model handled by this element.

      Call this method before a simulation run, if you need access to
      (nearly) all simulated series of the handled model after the
      simulation run is finished.

      By default, the series are stored in RAM, which is the faster
      option.  If your RAM is limited, pass the *False* for function
      argument *ramflag* to store the series on disk.

   prepare_inputseries(ramflag=True)

      Prepare the series objects of the *input* sequences of the model
      handled by this element.

      See method

      prepare_allseries()

       for further information.

   prepare_fluxseries(ramflag=True)

      Prepare the series objects of the *flux* sequences of the model
      handled by this element.

      See method

      prepare_allseries()

       for further information.

   prepare_stateseries(ramflag=True)

      Prepare the series objects of the *state* sequences of the model
      handled by this element.

      See method

      prepare_allseries()

       for further information.

   plot_inputseries(names=None, **kwargs)

      Plot the *input* series of the handled model.

      To plot the series of a subset of all sequences, pass the
      respective names.

   plot_fluxseries(names=None, **kwargs)

      Plot the *flux* series of the handled model.

      To plot the series of a subset of all sequences, pass the
      respective names.

   plot_stateseries(names=None, **kwargs)

      Plot the *state* series of the handled model.

      To plot the series of a subset of all sequences, pass the
      respective names.

   assignrepr(prefix)

      Defines the *visual appearence* of

      Element

       objects.

      You can pass a string which prefixes the string representation.

class hydpy.core.devicetools.Devices(*values)

   Bases:

   object

   Base class for class

   Elements

    and class

   Nodes

   .

   There are only small differences between class

   Elements

    and class

   Nodes

   .  We focus our explanations on class

   Nodes

    arbitrarily.

   The following test objects are used to explain the methods and
   properties of class

   Device

    (note the different types of the initialization arguments):

   >>> from hydpy import dummies
   >>> from hydpy import Node, Nodes, Element, Elements
   >>> dummies.nodes = Nodes('na',
   ...                       Node('nb', variable='W'),
   ...                       Node('nc', keywords=('group_a', 'group_1')),
   ...                       Node('nd', keywords=('group_a', 'group_2')),
   ...                       Node('ne', keywords=('group_b', 'group_1')))
   >>> dummies.elements = Elements('ea', Element('eb'))

   In a nutshell,

   Devices

    instances are containers supporting attribute access.  You can
   access each device directly by its name:

   >>> nodes = dummies.nodes
   >>> nodes.na
   Node("na", variable="Q")

   Wrong device names result in the following error message:

   >>> nodes.na_
   Traceback (most recent call last):
   ...
   AttributeError: The selected Nodes object has neither a `na_` attribute nor does it handle a Node object with name or keyword `na_`, which could be returned.

   Sometimes it is more convenient to receive empty always iterables,
   even empty ones (especially when using keyword access, see below).
   This cann be done by change the *return_always_iterables* class
   flag:

   >>> Nodes.return_always_iterables = True
   >>> nodes.na_
   Nodes()
   >>> nodes.na
   Nodes("na")
   >>> Nodes.return_always_iterables = False

   Attribute deleting is supported:

   >>> 'na' in nodes
   True
   >>> del nodes.na
   >>> 'na' in nodes
   False
   >>> del nodes.na
   Traceback (most recent call last):
   ...
   AttributeError: The selected Nodes object has neither a `na` attribute nor does it handle a Node object named `na`, which could be deleted.

   However, exemplified by the next example, setting devices as
   attributes "pythonically" could result in inconsistencies and is
   not allowed (see method

   add_device()

    instead):

   >>> nodes.NF = Node('nf')
   Traceback (most recent call last):
   ...
   NotImplementedError: Setting attributes of Nodes objects could result in confusion whether a new attribute should be handled as a Node object or as a "normal" attribute and is thus not support.

   The operators *+*, *+=*, *-* and *-=* support adding and removing
   groups of devices:

   >>> subgroup = Nodes("nc", "ne")

   >>> nodes
   Nodes("nb", "nc", "nd", "ne")
   >>> subgroup
   Nodes("nc", "ne")
   >>> nodes - subgroup
   Nodes("nb", "nd")

   >>> nodes
   Nodes("nb", "nc", "nd", "ne")
   >>> nodes -= subgroup
   >>> nodes
   Nodes("nb", "nd")

   >>> nodes + subgroup
   Nodes("nb", "nc", "nd", "ne")
   >>> nodes
   Nodes("nb", "nd")
   >>> nodes += subgroup
   >>> nodes
   Nodes("nb", "nc", "nd", "ne")

   Trying to add already existing are to remove non existing devices
   does no harm:

   >>> nodes
   Nodes("nb", "nc", "nd", "ne")
   >>> nodes + subgroup
   Nodes("nb", "nc", "nd", "ne")
   >>> nodes - Node('na')
   Nodes("nb", "nc", "nd", "ne")

   Finally, the following "set operators" are supported:

   >>> subgroup < nodes, nodes < subgroup, nodes < nodes
   (True, False, False)
   >>> subgroup <= nodes, nodes <= subgroup, nodes <= nodes
   (True, False, True)
   >>> subgroup == nodes, nodes == subgroup, nodes == nodes
   (False, False, True)
   >>> subgroup != nodes, nodes != subgroup, nodes != nodes
   (True, True, False)
   >>> subgroup >= nodes, nodes >= subgroup, nodes >= nodes
   (False, True, True)
   >>> subgroup > nodes, nodes > subgroup, nodes > nodes
   (False, True, False)

   return_always_iterables = False

   add_device(device)

      Add the given

      Node

       or

      Element

       object.

      >>> from hydpy import Nodes
      >>> nodes = Nodes('old_node')
      >>> nodes.add_device('new_node')
      >>> nodes
      Nodes("new_node", "old_node")

      Note the implementation detail, that each new node knows the
      object it was added to:

      >>> nodes in nodes.new_node._handlers
      True

   remove_device(device)

      Remove the given

      Node

       or

      Element

       object.

      >>> from hydpy import Node, Nodes
      >>> nodes = Nodes('node_x', 'node_y')
      >>> node_x, node_y = nodes
      >>> nodes.remove_device('node_y')
      >>> nodes
      Nodes("node_x")

      Note the implementation detail, that a new node forgots its
      container object, after it has been removed:

      >>> nodes in node_x._handlers
      True
      >>> nodes in node_y._handlers
      False

   names

      A sorted tuple of the names of the handled devices.

      >>> from hydpy import dummies
      >>> dummies.nodes.names
      ('na', 'nb', 'nc', 'nd', 'ne')

   devices

      A tuple of the handled devices sorted by the device names.

      >>> from hydpy import dummies
      >>> tuple(device.name for device in dummies.nodes.devices)
      ('na', 'nb', 'nc', 'nd', 'ne')

   keywords

      A set of all keywords of all handled devices.

      In addition to attribute access via device names described
      above,

      Device

       objects allow for attribute access via keywords. This allows
      for an efficient search of certain groups of devices. Lets use
      the example from above, where the nodes *na* and *nb* have no
      keywords but each of the other three nodes both belongs to
      either *group_a* or *group_b* and *group_1* or *group_2*:

      >>> from hydpy import dummies
      >>> nodes = dummies.nodes
      >>> nodes
      Nodes("na", "nb", "nc", "nd", "ne")
      >>> sorted(nodes.keywords)
      ['group_1', 'group_2', 'group_a', 'group_b']

      If you are interesting in inspecting all nodes belonging to
      *group_a*, build a selection:

      >>> subgroup = nodes.group_1
      >>> subgroup
      Nodes("nc", "ne")

      You can further restrict the search by also selecting the nodes
      also belonging to *group_b*, which holds true for node *ne*
      only:

      >>> subsubgroup = subgroup.group_b
      >>> subsubgroup
      Node("ne", variable="Q",
           keywords=["group_1", "group_b"])

      Node that the keywords already used for building a subgroup of
      nodes are no informative anymore (as they hold true for each
      node) and are thus not shown anymore:

      >>> sorted(subgroup.keywords)
      ['group_a', 'group_b']

      The latter might be confusing, if you intend to work with a
      subgroup of nodes for a longer time.  After copying the
      subgroup, all keywords of the contained devices are available
      again:

      >>> newgroup = subgroup.copy()
      >>> sorted(newgroup.keywords)
      ['group_1', 'group_a', 'group_b']

   open_files(idx=0)

      Call method

      open_files()

       or

      open_files()

       of all contained

      Node

       or

      Element

       objects.

   close_files()

      Call method

      close_files()

       or

      close_files()

       of all contained

      Node

       or

      Element

       objects.

   copy()

      Return a shallow copy of the actual

      Devices

       instance.

      Make a flat copy of the

      Nodes

       object defined above:

      >>> from hydpy import dummies
      >>> old = dummies.nodes
      >>> import copy
      >>> new = copy.copy(old)

      Show that the copy is not completely flat:

      >>> new == old
      True
      >>> new is old
      False
      >>> new._devices is old._devices
      False
      >>> new.na is new.na
      True

      The private variable *_devices* obviously has also been copied,
      but not the device *na*.  Allowing also to copy devices like
      *na* would be in conflict with using their names as identifiers.
      For this reason deep copying

      Devices

       objects is disabled:

      >>> copy.deepcopy(dummies.nodes)
      Traceback (most recent call last):
      ...
      NotImplementedError: Deep copying of Nodes objects is not supported, as it would require to make deep copies of the Node objects themselves, which is in conflict with using their names as identifiers.

   assignrepr(prefix)

      Return a string representation of the actual

      Devices

       object prefixed with the given string.

class hydpy.core.devicetools.Nodes(*values)

   Bases:

   hydpy.core.devicetools.Devices

   A container for handling

   Node

    objects.

   prepare_allseries(ramflag=True)

      Call methods

      prepare_simseries()

       and | Node.prepare_obsseries|.

   prepare_simseries(ramflag=True)

      Call method

      prepare_simseries()

       of each handled

      Node

       object.

   prepare_obsseries(ramflag=True)

      Call method

      prepare_obsseries()

       of each handled

      Node

       object.

   save_allseries()

      Call methods

      save_simseries()

       and

      save_obsseries()

      .

   save_simseries(ramflag=True)

      Call method

      save_ext()

       of all  "memory flag activated"

      NodeSequence

       objects storing simulated  values handled (indirectly) by each

      Node

       object.

   save_obsseries(ramflag=True)

      Call method

      save_ext()

       of all "memory flag activated"

      NodeSequence

       objects storing observed values handled (indirectly) by each

      Node

       object.

class hydpy.core.devicetools.Elements(*values)

   Bases:

   hydpy.core.devicetools.Devices

   A container for handling

   Element

    objects.

   init_models()

      Call method

      init_model()

       of each handled

      Element

       object and afterwards method

      update()

       of the

      Parameters

       object handled (indirectly) by each

      Element

       object.

   connect()

      Call method

      connect()

       of each

      Element

       object and function

      update()

       of the

      Parameters

       object handled (indirectly) by each

      Element

       object.

   save_controls(controldir=None, projectdir=None, parameterstep=None, simulationstep=None, auxfiler=None)

      Save the control parameters of the

      Model

       object handled by each

      Element

       object and eventually the ones handled by the given

      Auxfiler

       object.

   load_conditions(conditiondir=None, projectdir=None)

      Save the initial conditions of the

      Model

       object handled by each

      Element

       object.

   save_conditions(conditiondir=None, projectdir=None, controldir=None)

      Save the calculated conditions of the

      Model

       object handled by each

      Element

       object.

   trim_conditions()

      Call method

      trim_conditions()

       of the

      Sequences

       object handled (indirectly) by each

      Element

       object.

   reset_conditions()

      Call method

      reset()

       of the

      Sequences

       object handled (indirectly) by each

      Element

       object.

   prepare_allseries(ramflag=True)

      Call method

      prepare_allseries()

       of each handled

      Element

       object.

   prepare_inputseries(ramflag=True)

      Call method

      prepare_inputseries()

       of each handled

      Element

       object.

   prepare_fluxseries(ramflag=True)

      Call method

      prepare_fluxseries()

       of each handled

      Element

       object.

   prepare_stateseries(ramflag=True)

      Call method

      prepare_stateseries()

       of each handled

      Element

       object.

   save_allseries()

      Call methods

      save_inputseries()

      ,

      save_fluxseries()

      , and

      save_stateseries()

      .

   save_inputseries()

      Call method

      save_ext()

       of all "memory flag activated"

      InputSequence

       objects handled (indirectly) by each

      Element

       object.

   save_fluxseries()

      Call method

      save_ext()

       of all "memory flag activated"

      FluxSequence

       objects handled (indirectly) by each

      Element

       object.

   save_stateseries()

      Call method

      save_ext()

       of all "memory flag activated"

      StateSequence

       objects handled (indirectly) by each

      Element

       object.
