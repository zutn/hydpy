
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>hydpy.auxs.statstools &#8212; HydPy 2.1-dev documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 2.1-dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.auxs.statstools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;This module implements statistical functionalities frequently used in</span>
<span class="sd">hydrological modelling.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="c1"># ...from site-packages</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">hydpy</span> <span class="k">import</span> <span class="n">pandas</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">special</span>
<span class="c1"># ...from HydPy</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="k">import</span> <span class="n">autodoctools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="k">import</span> <span class="n">objecttools</span>
<span class="kn">from</span> <span class="nn">hydpy.auxs</span> <span class="k">import</span> <span class="n">validtools</span>


<div class="viewcode-block" id="prepare_arrays"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.prepare_arrays">[docs]</a><span class="k">def</span> <span class="nf">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prepare and return two |numpy| arrays based on the given arguments.</span>

<span class="sd">    Note that many functions provided by module |statstools| apply function</span>
<span class="sd">    |prepare_arrays| internally (e.g. |nse|).  But you can also apply it</span>
<span class="sd">    manually, as shown in the following examples.</span>

<span class="sd">    Function |prepare_arrays| can extract time series data from |Node|</span>
<span class="sd">    objects.  To set up an example for this, we define a initialization</span>
<span class="sd">    time period and prepare a |Node| object:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids, Node, round_, nan</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,</span>
<span class="sd">    ...                                    &#39;07.01.2000&#39;,</span>
<span class="sd">    ...                                    &#39;1d&#39;))</span>
<span class="sd">    &gt;&gt;&gt; node = Node(&#39;test&#39;)</span>

<span class="sd">    Next, we assign values the `simulation` and the `observation` sequences</span>
<span class="sd">    (to do so for the `observation` sequence requires a little trick, as</span>
<span class="sd">    its values are normally supposed to be read from a file):</span>

<span class="sd">    &gt;&gt;&gt; node.prepare_simseries()</span>
<span class="sd">    &gt;&gt;&gt; node.sequences.sim.series = 1.0, nan, nan, nan, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; node.sequences.obs.ramflag = True</span>
<span class="sd">    &gt;&gt;&gt; node.sequences.obs._setarray([4.0, 5.0, nan, nan, nan, 6.0])</span>

<span class="sd">    Now we can pass the node object to function |prepare_arrays| and</span>
<span class="sd">    get the (unmodified) time series data:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import prepare_arrays</span>
<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays[0])</span>
<span class="sd">    1.0, nan, nan, nan, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays[1])</span>
<span class="sd">    4.0, 5.0, nan, nan, nan, 6.0</span>

<span class="sd">    Alternatively, we can pass directly any iterables (e.g. |list| and</span>
<span class="sd">    |tuple| objects) containing the `simulated` and `observed` data:</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(sim=list(node.sequences.sim.series),</span>
<span class="sd">    ...                         obs=tuple(node.sequences.obs.series))</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays[0])</span>
<span class="sd">    1.0, nan, nan, nan, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays[1])</span>
<span class="sd">    4.0, 5.0, nan, nan, nan, 6.0</span>

<span class="sd">    The optional `skip_nan` flag allows to skip all values, which are</span>
<span class="sd">    no numbers.  Note that only those pairs of `simulated` and `observed`</span>
<span class="sd">    values are returned which do not contain any `nan`:</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node, skip_nan=True)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays[0])</span>
<span class="sd">    1.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays[1])</span>
<span class="sd">    4.0, 6.0</span>

<span class="sd">    The final examples show the error messages returned in case of</span>
<span class="sd">    invalid combinations of input arguments:</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Neither a `Node` object is passed to argument `node` nor \</span>
<span class="sd">are arrays passed to arguments `sim` and `obs`.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(sim=node.sequences.sim.series, node=node)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Values are passed to both arguments `sim` and `node`, \</span>
<span class="sd">which is not allowed.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(obs=node.sequences.obs.series, node=node)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Values are passed to both arguments `obs` and `node`, \</span>
<span class="sd">which is not allowed.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(sim=node.sequences.sim.series)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: A value is passed to argument `sim` but \</span>
<span class="sd">no value is passed to argument `obs`.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(obs=node.sequences.obs.series)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: A value is passed to argument `obs` but \</span>
<span class="sd">no value is passed to argument `sim`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Values are passed to both arguments `sim` and `node`, &#39;</span>
                <span class="s1">&#39;which is not allowed.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Values are passed to both arguments `obs` and `node`, &#39;</span>
                <span class="s1">&#39;which is not allowed.&#39;</span><span class="p">)</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">series</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">series</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;A value is passed to argument `sim` &#39;</span>
            <span class="s1">&#39;but no value is passed to argument `obs`.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;A value is passed to argument `obs` &#39;</span>
            <span class="s1">&#39;but no value is passed to argument `sim`.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Neither a `Node` object is passed to argument `node` nor &#39;</span>
            <span class="s1">&#39;are arrays passed to arguments `sim` and `obs`.&#39;</span><span class="p">)</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">skip_nan</span><span class="p">:</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span> <span class="o">*</span> <span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span></div>


<div class="viewcode-block" id="nse"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.nse">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the Nash-Sutcliffe efficiency&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nse</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the efficiency criteria after Nash &amp; Sutcliffe.</span>

<span class="sd">    If the simulated values predict the observed values as well</span>
<span class="sd">    as the average observed value (regarding the the mean square</span>
<span class="sd">    error), the NSE value is zero:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import nse</span>
<span class="sd">    &gt;&gt;&gt; nse(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; nse(sim=[0.0, 2.0, 4.0], obs=[1.0, 2.0, 3.0])</span>
<span class="sd">    0.0</span>

<span class="sd">    For worse and better simulated values the NSE is negative</span>
<span class="sd">    or positive, respectively:</span>

<span class="sd">    &gt;&gt;&gt; nse(sim=[3.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0])</span>
<span class="sd">    -3.0</span>
<span class="sd">    &gt;&gt;&gt; nse(sim=[1.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0])</span>
<span class="sd">    0.5</span>

<span class="sd">    The highest possible value is one:</span>

<span class="sd">    &gt;&gt;&gt; nse(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0])</span>
<span class="sd">    1.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some</span>
<span class="sd">    additional instructions for use of function |nse|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sim</span><span class="o">-</span><span class="n">obs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">obs</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">obs</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="bias_abs"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.bias_abs">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the absolute bias&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bias_abs</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the absolute difference between the means of the simulated</span>
<span class="sd">    and the observed values.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import bias_abs</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_abs(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_abs(sim=[5.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_abs(sim=[1.0, 1.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -1.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some</span>
<span class="sd">    additional instructions for use of function |bias_abs|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim</span><span class="o">-</span><span class="n">obs</span><span class="p">)</span></div>


<div class="viewcode-block" id="bias_rel"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.bias_rel">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the relative bias&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bias_rel</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the relative difference between the means of the simulated</span>
<span class="sd">    and the observed values.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import bias_rel</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_rel(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_rel(sim=[5.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_rel(sim=[1.0, 1.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -0.5</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some</span>
<span class="sd">    additional instructions for use of function |bias_rel|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span></div>


<div class="viewcode-block" id="std_ratio"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.std_ratio">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the standard deviation ratio&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">std_ratio</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the ratio between the standard deviation of the simulated</span>
<span class="sd">    and the observed values.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import std_ratio</span>
<span class="sd">    &gt;&gt;&gt; round_(std_ratio(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(std_ratio(sim=[1.0, 1.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(std_ratio(sim=[0.0, 3.0, 6.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    2.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some</span>
<span class="sd">    additional instructions for use of function |std_ratio|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span></div>


<div class="viewcode-block" id="corr"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.corr">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the Pearson correlation coefficient&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the product-moment correlation coefficient after Pearson.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import corr</span>
<span class="sd">    &gt;&gt;&gt; round_(corr(sim=[0.5, 1.0, 1.5], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(corr(sim=[4.0, 2.0, 0.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(corr(sim=[1.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some</span>
<span class="sd">    additional instructions for use of function |corr|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_pars_sepd</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
    <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">gamma1</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">beta</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">gamma2</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">beta</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">w_beta</span> <span class="o">=</span> <span class="n">gamma1</span><span class="o">**.</span><span class="mi">5</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma2</span><span class="o">**</span><span class="mf">1.5</span>
    <span class="n">c_beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma1</span><span class="o">/</span><span class="n">gamma2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">beta</span><span class="p">))</span>
    <span class="n">m_1</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma1</span><span class="o">**.</span><span class="mi">5</span> <span class="o">/</span> <span class="n">gamma2</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">m_2</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">mu_xi</span> <span class="o">=</span> <span class="n">m_1</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">sigma_xi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">m_2</span><span class="o">-</span><span class="n">m_1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">m_1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">m_2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mu_xi</span><span class="p">,</span> <span class="n">sigma_xi</span><span class="p">,</span> <span class="n">w_beta</span><span class="p">,</span> <span class="n">c_beta</span>


<span class="k">def</span> <span class="nf">_pars_h</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sigma1</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigma2</span><span class="o">*</span><span class="n">sim</span>


<div class="viewcode-block" id="hsepd_pdf"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.hsepd_pdf">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the probability densities with the &#39;</span>
    <span class="s1">&#39;heteroskedastic skewed exponential power distribution&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hsepd_pdf</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
              <span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the probability densities based on the</span>
<span class="sd">    heteroskedastic skewed exponential power distribution.</span>

<span class="sd">    For convenience, the required parameters of the probability density</span>
<span class="sd">    function as well as the simulated and observed values are stored</span>
<span class="sd">    in a dictonary:</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import hsepd_pdf</span>
<span class="sd">    &gt;&gt;&gt; general = {&#39;sigma1&#39;: 0.2,</span>
<span class="sd">    ...            &#39;sigma2&#39;: 0.0,</span>
<span class="sd">    ...            &#39;xi&#39;: 1.0,</span>
<span class="sd">    ...            &#39;beta&#39;: 0.0,</span>
<span class="sd">    ...            &#39;sim&#39;: numpy.arange(10.0, 41.0),</span>
<span class="sd">    ...            &#39;obs&#39;: numpy.full(31, 25.0)}</span>

<span class="sd">    The following test function allows the variation of one parameter</span>
<span class="sd">    and prints some and plots all of probability density values</span>
<span class="sd">    corresponding to different simulated values:</span>

<span class="sd">    &gt;&gt;&gt; def test(**kwargs):</span>
<span class="sd">    ...     from matplotlib import pyplot</span>
<span class="sd">    ...     special = general.copy()</span>
<span class="sd">    ...     name, values = list(kwargs.items())[0]</span>
<span class="sd">    ...     results = numpy.zeros((len(general[&#39;sim&#39;]), len(values)+1))</span>
<span class="sd">    ...     results[:, 0] = general[&#39;sim&#39;]</span>
<span class="sd">    ...     for jdx, value in enumerate(values):</span>
<span class="sd">    ...         special[name] = value</span>
<span class="sd">    ...         results[:, jdx+1] = hsepd_pdf(**special)</span>
<span class="sd">    ...         pyplot.plot(results[:, 0], results[:, jdx+1],</span>
<span class="sd">    ...                     label=&#39;%s=%.1f&#39; % (name, value))</span>
<span class="sd">    ...     pyplot.legend()</span>
<span class="sd">    ...     for idx, result in enumerate(results):</span>
<span class="sd">    ...         if not (idx % 5):</span>
<span class="sd">    ...             round_(result)</span>

<span class="sd">    When varying parameter `beta`, the resulting probabilities correspond</span>
<span class="sd">    to the Laplace distribution (1.0), normal distribution (0.0), and the</span>
<span class="sd">    uniform distribution (-1.0), respectively.  Note that we use -0.99</span>
<span class="sd">    instead of -1.0 for approximating the uniform distribution to prevent</span>
<span class="sd">    from running into numerical problems, which are not solved yet:</span>

<span class="sd">    &gt;&gt;&gt; test(beta=[1.0, 0.0, -0.99])</span>
<span class="sd">    10.0, 0.002032, 0.000886, 0.0</span>
<span class="sd">    15.0, 0.008359, 0.010798, 0.0</span>
<span class="sd">    20.0, 0.034382, 0.048394, 0.057739</span>
<span class="sd">    25.0, 0.141421, 0.079788, 0.057739</span>
<span class="sd">    30.0, 0.034382, 0.048394, 0.057739</span>
<span class="sd">    35.0, 0.008359, 0.010798, 0.0</span>
<span class="sd">    40.0, 0.002032, 0.000886, 0.0</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from matplotlib import pyplot</span>
<span class="sd">        &gt;&gt;&gt; pyplot.close()</span>

<span class="sd">    When varying parameter `xi`, the resulting density is negatively</span>
<span class="sd">    skewed (0.2), symmetric (1.0), and positively skewed (5.0),</span>
<span class="sd">    respectively:</span>

<span class="sd">    &gt;&gt;&gt; test(xi=[0.2, 1.0, 5.0])</span>
<span class="sd">    10.0, 0.0, 0.000886, 0.003175</span>
<span class="sd">    15.0, 0.0, 0.010798, 0.012957</span>
<span class="sd">    20.0, 0.092845, 0.048394, 0.036341</span>
<span class="sd">    25.0, 0.070063, 0.079788, 0.070063</span>
<span class="sd">    30.0, 0.036341, 0.048394, 0.092845</span>
<span class="sd">    35.0, 0.012957, 0.010798, 0.0</span>
<span class="sd">    40.0, 0.003175, 0.000886, 0.0</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from matplotlib import pyplot</span>
<span class="sd">        &gt;&gt;&gt; pyplot.close()</span>

<span class="sd">    In the above examples, the actual `sigma` (5.0) is calculated by</span>
<span class="sd">    multiplying `sigma1` (0.2) with the mean simulated value (25.0),</span>
<span class="sd">    internally.  This can be done for modelling homoscedastic errors.</span>
<span class="sd">    Instead, `sigma2` is multiplied with the individual simulated values</span>
<span class="sd">    to account for heteroscedastic errors.  With increasing values of</span>
<span class="sd">    `sigma2`, the resulting densities are modified as follows:</span>

<span class="sd">    &gt;&gt;&gt; test(sigma2=[0.0, 0.1, 0.2])</span>
<span class="sd">    10.0, 0.000886, 0.002921, 0.005737</span>
<span class="sd">    15.0, 0.010798, 0.018795, 0.022831</span>
<span class="sd">    20.0, 0.048394, 0.044159, 0.037988</span>
<span class="sd">    25.0, 0.079788, 0.053192, 0.039894</span>
<span class="sd">    30.0, 0.048394, 0.04102, 0.032708</span>
<span class="sd">    35.0, 0.010798, 0.023493, 0.023493</span>
<span class="sd">    40.0, 0.000886, 0.011053, 0.015771</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from matplotlib import pyplot</span>
<span class="sd">        &gt;&gt;&gt; pyplot.close()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="n">sigmas</span> <span class="o">=</span> <span class="n">_pars_h</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
    <span class="n">mu_xi</span><span class="p">,</span> <span class="n">sigma_xi</span><span class="p">,</span> <span class="n">w_beta</span><span class="p">,</span> <span class="n">c_beta</span> <span class="o">=</span> <span class="n">_pars_sepd</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">obs</span><span class="p">,</span> <span class="n">sim</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sigmas</span>
    <span class="n">a_xi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">mu_xi</span><span class="o">+</span><span class="n">sigma_xi</span><span class="o">*</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mf">0.</span>
    <span class="n">a_xi</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">mu_xi</span><span class="o">+</span><span class="n">sigma_xi</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">idxs</span><span class="p">]))</span>
    <span class="n">a_xi</span><span class="p">[</span><span class="o">~</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">mu_xi</span><span class="o">+</span><span class="n">sigma_xi</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="o">~</span><span class="n">idxs</span><span class="p">]))</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">sigma_xi</span><span class="o">/</span><span class="p">(</span><span class="n">xi</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="n">xi</span><span class="p">)</span><span class="o">*</span><span class="n">w_beta</span> <span class="o">*</span>
          <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_beta</span><span class="o">*</span><span class="n">a_xi</span><span class="o">**</span><span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">beta</span><span class="p">))))</span><span class="o">/</span><span class="n">sigmas</span>
    <span class="k">return</span> <span class="n">ps</span></div>


<span class="k">def</span> <span class="nf">_hsepd_manual</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">):</span>
    <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">hsepd_pdf</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>
    <span class="n">ps</span><span class="p">[</span><span class="n">ps</span> <span class="o">&lt;</span> <span class="mf">1e-200</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-200</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span>


<div class="viewcode-block" id="hsepd_manual"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.hsepd_manual">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate an objective value based on method `hsepd_manual`&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hsepd_manual</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                 <span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the mean of the logarithmised probability densities of the</span>
<span class="sd">    &#39;heteroskedastic skewed exponential power distribution.</span>

<span class="sd">    The following examples are taken from the documentation of function</span>
<span class="sd">    |hsepd_pdf|, which is used by function |hsepd_manual|.  The first</span>
<span class="sd">    one deals with a heteroscedastic normal distribution:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import hsepd_manual</span>
<span class="sd">    &gt;&gt;&gt; round_(hsepd_manual(sigma1=0.2, sigma2=0.2,</span>
<span class="sd">    ...                     xi=1.0, beta=0.0,</span>
<span class="sd">    ...                     sim=numpy.arange(10.0, 41.0),</span>
<span class="sd">    ...                     obs=numpy.full(31, 25.0)))</span>
<span class="sd">    -3.682842</span>

<span class="sd">    The second one is supposed to show to small zero probability density</span>
<span class="sd">    values are set to 1e-200 before calculating their logarithm (which</span>
<span class="sd">    means that the lowest possible value returned by function</span>
<span class="sd">    |hsepd_manual| is approximately -460):</span>

<span class="sd">    &gt;&gt;&gt; round_(hsepd_manual(sigma1=0.2, sigma2=0.0,</span>
<span class="sd">    ...                     xi=1.0, beta=-0.99,</span>
<span class="sd">    ...                     sim=numpy.arange(10.0, 41.0),</span>
<span class="sd">    ...                     obs=numpy.full(31, 25.0)))</span>
<span class="sd">    -209.539335</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_hsepd_manual</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span></div>


<div class="viewcode-block" id="hsepd"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.hsepd">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate an objective value based on method `hsepd`&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hsepd</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">inits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_pars</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the mean of the logarithmised probability densities of the</span>
<span class="sd">    &#39;heteroskedastic skewed exponential power distribution.</span>

<span class="sd">    Function |hsepd| serves the same purpose as function |hsepd_manual|,</span>
<span class="sd">    but tries to estimate the parameters of the heteroscedastic skewed</span>
<span class="sd">    exponential distribution via an optimization algorithm.  This</span>
<span class="sd">    is shown by generating a random sample.  1000 simulated values</span>
<span class="sd">    are scattered around the observed (true) value of 10.0 with a</span>
<span class="sd">    standard deviation of 2.0:</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; numpy.random.seed(0)</span>
<span class="sd">    &gt;&gt;&gt; sim = numpy.random.normal(10.0, 2.0, 1000)</span>
<span class="sd">    &gt;&gt;&gt; obs = numpy.full(1000, 10.0)</span>

<span class="sd">    First, as a reference, we calculate the &quot;true&quot; value based on</span>
<span class="sd">    function |hsepd_manual| and the correct distribution parameters:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import hsepd, hsepd_manual</span>
<span class="sd">    &gt;&gt;&gt; round_(hsepd_manual(sigma1=0.2, sigma2=0.0,</span>
<span class="sd">    ...                     xi=1.0, beta=0.0,</span>
<span class="sd">    ...                     sim=sim, obs=obs))</span>
<span class="sd">    -2.100093</span>

<span class="sd">    When using function |hsepd|, the returned value is even a little</span>
<span class="sd">    &quot;better&quot;:</span>

<span class="sd">    &gt;&gt;&gt; round_(hsepd(sim=sim, obs=obs))</span>
<span class="sd">    -2.09983</span>

<span class="sd">    This is due to the deviation from the random sample to its</span>
<span class="sd">    theoretical distribution.  This is reflected by small differences</span>
<span class="sd">    between the estimated values and the theoretical values of</span>
<span class="sd">    `sigma1` (0.2), , `sigma2` (0.0), `xi` (1.0), and `beta` (0.0).</span>
<span class="sd">    The estimated values are returned in the mentioned order through</span>
<span class="sd">    enabling the `return_pars` option:</span>

<span class="sd">    &gt;&gt;&gt; value, pars = hsepd(sim=sim, obs=obs, return_pars=True)</span>
<span class="sd">    &gt;&gt;&gt; round_(pars, decimals=5)</span>
<span class="sd">    0.19966, 0.0, 0.96836, 0.0188</span>

<span class="sd">    There is no guarantee that the optimization numerical optimization</span>
<span class="sd">    algorithm underlying function |hsepd| will always find the parameters</span>
<span class="sd">    resulting in the largest value returned by function |hsepd_manual|.</span>
<span class="sd">    You can increase its robustness (and decrease computation time) by</span>
<span class="sd">    supplying good initial parameter values:</span>

<span class="sd">    &gt;&gt;&gt; value, pars = hsepd(sim=sim, obs=obs, return_pars=True,</span>
<span class="sd">    ...                     inits=(0.2, 0.0, 1.0, 0.0))</span>
<span class="sd">    &gt;&gt;&gt; round_(pars, decimals=5)</span>
<span class="sd">    0.19966, 0.0, 0.96836, 0.0188</span>

<span class="sd">    However, the following example shows a case when this strategie</span>
<span class="sd">    results in worse results:</span>

<span class="sd">    &gt;&gt;&gt; value, pars = hsepd(sim=sim, obs=obs, return_pars=True,</span>
<span class="sd">    ...                     inits=(0.0, 0.2, 1.0, 0.0))</span>
<span class="sd">    &gt;&gt;&gt; round_(value)</span>
<span class="sd">    -2.174492</span>
<span class="sd">    &gt;&gt;&gt; round_(pars)</span>
<span class="sd">    0.0, 0.213179, 1.705485, 0.505112</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=invalid-name</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">pars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform the actual optimization problem into a function to</span>
<span class="sd">        be minimized and apply parameter constraints.&quot;&quot;&quot;</span>
        <span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="o">*</span><span class="n">pars</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_hsepd_manual</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply constrains on the given parameter values.&quot;&quot;&quot;</span>
        <span class="n">sigma1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">sigma2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sigma2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span>

    <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inits</span><span class="p">:</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">inits</span><span class="p">,</span>
                           <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span>
                           <span class="n">disp</span><span class="o">=</span><span class="ow">not</span> <span class="n">silent</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>   <span class="c1"># pylint: disable=too-many-function-args</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_hsepd_manual</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_pars</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calc_mean_time"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.calc_mean_time">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the weighted mean time&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">calc_mean_time</span><span class="p">(</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the weighted mean of the given timepoints.</span>

<span class="sd">    With equal given weights, the result is simply the mean of the given</span>
<span class="sd">    time points:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import calc_mean_time</span>
<span class="sd">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],</span>
<span class="sd">    ...                weights=[2., 2.])</span>
<span class="sd">    5.0</span>

<span class="sd">    With different weights, the resulting mean time is shifted to the larger</span>
<span class="sd">    ones:</span>

<span class="sd">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],</span>
<span class="sd">    ...                weights=[1., 3.])</span>
<span class="sd">    6.0</span>

<span class="sd">    Or, in the most extreme case:</span>

<span class="sd">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],</span>
<span class="sd">    ...                weights=[0., 4.])</span>
<span class="sd">    7.0</span>

<span class="sd">    There will be some checks for input plausibility perfomed, e.g.:</span>

<span class="sd">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],</span>
<span class="sd">    ...                weights=[-2., 2.])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to calculate the weighted mean time, \</span>
<span class="sd">the following error occured: For the following objects, at least \</span>
<span class="sd">one value is negative: weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timepoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timepoints</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_equal_shape</span><span class="p">(</span><span class="n">timepoints</span><span class="o">=</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_non_negative</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="calc_mean_time_deviation"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.calc_mean_time_deviation">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;calculate the weighted time deviation from mean time&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">calc_mean_time_deviation</span><span class="p">(</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mean_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the weighted deviation of the given timepoints from their mean</span>
<span class="sd">    time.</span>

<span class="sd">    With equal given weights, the is simply the standard deviation of the</span>
<span class="sd">    given time points:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import calc_mean_time_deviation</span>
<span class="sd">    &gt;&gt;&gt; calc_mean_time_deviation(timepoints=[3., 7.],</span>
<span class="sd">    ...                          weights=[2., 2.])</span>
<span class="sd">    2.0</span>

<span class="sd">    One can pass a precalculated or alternate mean time:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time_deviation(timepoints=[3., 7.],</span>
<span class="sd">    ...                                 weights=[2., 2.],</span>
<span class="sd">    ...                                 mean_time=4.))</span>
<span class="sd">    2.236068</span>

<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time_deviation(timepoints=[3., 7.],</span>
<span class="sd">    ...                                 weights=[1., 3.]))</span>
<span class="sd">    1.732051</span>

<span class="sd">    Or, in the most extreme case:</span>

<span class="sd">    &gt;&gt;&gt; calc_mean_time_deviation(timepoints=[3., 7.],</span>
<span class="sd">    ...                          weights=[0., 4.])</span>
<span class="sd">    0.0</span>

<span class="sd">    There will be some checks for input plausibility perfomed, e.g.:</span>

<span class="sd">    &gt;&gt;&gt; calc_mean_time_deviation(timepoints=[3., 7.],</span>
<span class="sd">    ...                          weights=[-2., 2.])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to calculate the weighted time deviation \</span>
<span class="sd">from mean time, the following error occured: For the following objects, \</span>
<span class="sd">at least one value is negative: weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timepoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timepoints</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_equal_shape</span><span class="p">(</span><span class="n">timepoints</span><span class="o">=</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_non_negative</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mean_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mean_time</span> <span class="o">=</span> <span class="n">calc_mean_time</span><span class="p">(</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">timepoints</span><span class="o">-</span><span class="n">mean_time</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                       <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)))</span></div>


<div class="viewcode-block" id="evaluationtable"><a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.evaluationtable">[docs]</a><span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s1">&#39;evaluate the simulation results of some node objects&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">evaluationtable</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">criteria</span><span class="p">,</span> <span class="n">nodenames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">critnames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a table containing the results of the given evaluation</span>
<span class="sd">    criteria for the given |Node| objects.</span>

<span class="sd">    First, we define two nodes with different simulation and observation</span>
<span class="sd">    data (see function |prepare_arrays| for some explanations):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids, Node, round_, nan</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,</span>
<span class="sd">    ...                                    &#39;04.01.2000&#39;,</span>
<span class="sd">    ...                                    &#39;1d&#39;))</span>
<span class="sd">    &gt;&gt;&gt; nodes = Node(&#39;test1&#39;), Node(&#39;test2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for node in nodes:</span>
<span class="sd">    ...     node.prepare_simseries()</span>
<span class="sd">    ...     node.sequences.sim.series = 1.0, 2.0, 3.0</span>
<span class="sd">    ...     node.sequences.obs.ramflag = True</span>
<span class="sd">    ...     node.sequences.obs._setarray([4.0, 5.0, 6.0])</span>
<span class="sd">    &gt;&gt;&gt; nodes[0].sequences.sim.series = 1.0, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; nodes[0].sequences.obs._setarray([4.0, 5.0, 6.0])</span>
<span class="sd">    &gt;&gt;&gt; nodes[1].sequences.sim.series = 1.0, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; nodes[1].sequences.obs._setarray([3.0, nan, 1.0])</span>

<span class="sd">    Selecting functions |corr| and |bias_abs| as evaluation criteria,</span>
<span class="sd">    function |evaluationtable| returns the following table (which is</span>
<span class="sd">    actually a pandas data frame):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import evaluationtable, corr, bias_abs</span>
<span class="sd">    &gt;&gt;&gt; evaluationtable(nodes, (corr, bias_abs))</span>
<span class="sd">           corr  bias_abs</span>
<span class="sd">    test1   1.0      -3.0</span>
<span class="sd">    test2   NaN       NaN</span>

<span class="sd">    One can pass alternative names for both the node objects and the</span>
<span class="sd">    criteria functions.  Also, `nan` values can be skipped:</span>

<span class="sd">    &gt;&gt;&gt; evaluationtable(nodes, (corr, bias_abs),</span>
<span class="sd">    ...                 nodenames=(&#39;first node&#39;, &#39;second node&#39;),</span>
<span class="sd">    ...                 critnames=(&#39;corrcoef&#39;, &#39;bias&#39;),</span>
<span class="sd">    ...                 skip_nan=True)</span>
<span class="sd">                 corrcoef  bias</span>
<span class="sd">    first node        1.0  -3.0</span>
<span class="sd">    second node      -1.0   0.0</span>

<span class="sd">    The number of assigned node objects and criteria functions must</span>
<span class="sd">    match the number of givern alternative names:</span>

<span class="sd">    &gt;&gt;&gt; evaluationtable(nodes, (corr, bias_abs),</span>
<span class="sd">    ...                 nodenames=(&#39;first node&#39;,))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to evaluate the simulation results of some \</span>
<span class="sd">node objects, the following error occured: 2 node objects are given \</span>
<span class="sd">which does not match with number of given alternative names beeing 1.</span>

<span class="sd">    &gt;&gt;&gt; evaluationtable(nodes, (corr, bias_abs),</span>
<span class="sd">    ...                 critnames=(&#39;corrcoef&#39;,))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to evaluate the simulation results of some \</span>
<span class="sd">node objects, the following error occured: 2 criteria functions are given \</span>
<span class="sd">which does not match with number of given alternative names beeing 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodenames</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodenames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> node objects are given which does not match with &#39;</span>
                <span class="s1">&#39;number of given alternative names beeing </span><span class="si">%s</span><span class="s1">.&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodenames</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">critnames</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">critnames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> criteria functions are given which does not match &#39;</span>
                <span class="s1">&#39;with number of given alternative names beeing </span><span class="si">%s</span><span class="s1">.&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">critnames</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">critnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">crit</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">crit</span> <span class="ow">in</span> <span class="n">criteria</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">criterion</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">criteria</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">nodenames</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">critnames</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>


<span class="n">autodoctools</span><span class="o">.</span><span class="n">autodoc_module</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../framework.html">Framework Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modelcollection.html">Model Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 2.1-dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Christoph Tyralla.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>